const Zo=Math.PI*2;var I={EPS:1e-5,NEPS:1e-13,TAU:Zo};const Ho=(t,e)=>(t[0]=Math.abs(e[0]),t[1]=Math.abs(e[1]),t);var Uo=Ho;const Xo=(t,e,n)=>(t[0]=e[0]+n[0],t[1]=e[1]+n[1],t);var Yo=Xo;const Wo=t=>Math.atan2(t[1],t[0]);var ze=Wo,Ko=ze;const Qo=ze,Jo=t=>Qo(t)*57.29577951308232;var jo=Jo;const tr=()=>[0,0];var te=tr;const er=te,nr=t=>{const e=er();return e[0]=t[0],e[1]=t[1],e};var sr=nr;const or=(t,e)=>(t[0]=e[0],t[1]=e[1],t);var rr=or;const cr=(t,e,n)=>(t[0]=0,t[1]=0,t[2]=e[0]*n[1]-e[1]*n[0],t);var ir=cr;const ar=(t,e)=>{const n=e[0]-t[0],s=e[1]-t[1];return Math.sqrt(n*n+s*s)};var lr=ar;const fr=(t,e,n)=>(t[0]=e[0]/n[0],t[1]=e[1]/n[1],t);var hr=fr;const pr=(t,e)=>t[0]*e[0]+t[1]*e[1];var dr=pr;const ur=(t,e)=>t[0]===e[0]&&t[1]===e[1];var gr=ur;const{NEPS:vr}=I,Os=t=>Math.abs(t)<vr?0:t,$r=t=>Os(Math.sin(t)),mr=t=>Os(Math.cos(t));var Q={sin:$r,cos:mr};const{sin:yr,cos:wr}=Q,Pr=(t,e)=>(t[0]=wr(e),t[1]=yr(e),t);var zs=Pr;const xr=zs,Er=(t,e)=>xr(t,e*.017453292519943295);var _r=Er;const Ar=(t,e)=>(t[0]=e,t[1]=e,t);var Sr=Ar;const br=te,Mr=(t,e)=>{const n=br();return n[0]=t,n[1]=e,n};var Tr=Mr;const Fr=t=>Math.sqrt(t[0]*t[0]+t[1]*t[1]);var Vr=Fr;const kr=(t,e,n,s)=>{const o=e[0],r=e[1];return t[0]=o+s*(n[0]-o),t[1]=r+s*(n[1]-r),t};var Nr=kr;const qr=(t,e,n)=>(t[0]=Math.max(e[0],n[0]),t[1]=Math.max(e[1],n[1]),t);var Cr=qr;const Br=(t,e,n)=>(t[0]=Math.min(e[0],n[0]),t[1]=Math.min(e[1],n[1]),t);var Or=Br;const zr=(t,e,n)=>(t[0]=e[0]*n[0],t[1]=e[1]*n[1],t);var Dr=zr;const Rr=(t,e)=>(t[0]=-e[0],t[1]=-e[1],t);var Lr=Rr;const Ir=(t,e,n,s)=>{const o=e[0]-n[0],r=e[1]-n[1],c=Math.cos(s),i=Math.sin(s);return t[0]=o*c-r*i+n[0],t[1]=o*i+r*c+n[1],t};var Ds=Ir;const{TAU:Gr}=I,Zr=te,Hr=Ds,Ur=(t,e)=>Hr(t,e,Zr(),Gr/4);var Xr=Ur;const Yr=(t,e)=>{const n=e[0],s=e[1];let o=n*n+s*s;return o>0&&(o=1/Math.sqrt(o)),t[0]=n*o,t[1]=s*o,t};var Wr=Yr;const Kr=(t,e,n)=>(t[0]=e[0]*n,t[1]=e[1]*n,t);var Qr=Kr;const Jr=(t,e,n)=>(t[0]=Math.round(e[0]/n)*n+0,t[1]=Math.round(e[1]/n)*n+0,t);var jr=Jr;const tc=(t,e)=>{const n=e[0]-t[0],s=e[1]-t[1];return n*n+s*s};var ec=tc;const nc=t=>{const e=t[0],n=t[1];return e*e+n*n};var sc=nc;const oc=(t,e,n)=>(t[0]=e[0]-n[0],t[1]=e[1]-n[1],t);var rc=oc;const cc=t=>`[${t[0].toFixed(7)}, ${t[1].toFixed(7)}]`;var ic=cc;const ac=(t,e,n)=>{const s=e[0],o=e[1];return t[0]=n[0]*s+n[4]*o+n[12],t[1]=n[1]*s+n[5]*o+n[13],t};var lc=ac,k={abs:Uo,add:Yo,angle:Ko,angleDegrees:jo,angleRadians:ze,clone:sr,copy:rr,create:te,cross:ir,distance:lr,divide:hr,dot:dr,equals:gr,fromAngleDegrees:_r,fromAngleRadians:zs,fromScalar:Sr,fromValues:Tr,length:Vr,lerp:Nr,max:Cr,min:Or,multiply:Dr,negate:Lr,normal:Xr,normalize:Wr,rotate:Ds,scale:Qr,snap:jr,squaredDistance:ec,squaredLength:sc,subtract:rc,toString:ic,transform:lc};const fc=t=>Object.assign({},t);var De=fc;const{EPS:cn}=I,hc=k,pc=De,dc=t=>{if(t.isClosed)return t;const e=pc(t);if(e.isClosed=!0,e.points.length>1){const n=e.points,s=n[0];let o=n[n.length-1];for(;hc.distance(s,o)<cn*cn&&(n.pop(),n.length!==1);)o=n[n.length-1]}return e};var Rs=dc;const uc=(t,e,n)=>(t[0]=e[0]+n[0],t[1]=e[1]+n[1],t[2]=e[2]+n[2],t[3]=e[3]+n[3],t[4]=e[4]+n[4],t[5]=e[5]+n[5],t[6]=e[6]+n[6],t[7]=e[7]+n[7],t[8]=e[8]+n[8],t[9]=e[9]+n[9],t[10]=e[10]+n[10],t[11]=e[11]+n[11],t[12]=e[12]+n[12],t[13]=e[13]+n[13],t[14]=e[14]+n[14],t[15]=e[15]+n[15],t);var gc=uc;const vc=()=>[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1];var Re=vc;const $c=Re,mc=t=>{const e=$c();return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15],e};var yc=mc;const wc=(t,e)=>(t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],t[9]=e[9],t[10]=e[10],t[11]=e[11],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15],t);var Ls=wc;const Pc=(t,e)=>{const n=e[0],s=e[1],o=e[2],r=e[3],c=e[4],i=e[5],l=e[6],a=e[7],f=e[8],h=e[9],p=e[10],u=e[11],d=e[12],g=e[13],y=e[14],M=e[15],_=n*i-s*c,P=n*l-o*c,w=n*a-r*c,$=s*l-o*i,v=s*a-r*i,m=o*a-r*l,x=f*g-h*d,A=f*y-p*d,E=f*M-u*d,S=h*y-p*g,V=h*M-u*g,q=p*M-u*y;let F=_*q-P*V+w*S+$*E-v*A+m*x;return F?(F=1/F,t[0]=(i*q-l*V+a*S)*F,t[1]=(o*V-s*q-r*S)*F,t[2]=(g*m-y*v+M*$)*F,t[3]=(p*v-h*m-u*$)*F,t[4]=(l*E-c*q-a*A)*F,t[5]=(n*q-o*E+r*A)*F,t[6]=(y*w-d*m-M*P)*F,t[7]=(f*m-p*w+u*P)*F,t[8]=(c*V-i*E+a*x)*F,t[9]=(s*E-n*V-r*x)*F,t[10]=(d*v-g*w+M*_)*F,t[11]=(h*w-f*v-u*_)*F,t[12]=(i*A-c*S-l*x)*F,t[13]=(n*S-s*A+o*x)*F,t[14]=(g*P-d*$-y*_)*F,t[15]=(f*$-h*P+p*_)*F,t):null};var xc=Pc;const Ec=(t,e)=>t[0]===e[0]&&t[1]===e[1]&&t[2]===e[2]&&t[3]===e[3]&&t[4]===e[4]&&t[5]===e[5]&&t[6]===e[6]&&t[7]===e[7]&&t[8]===e[8]&&t[9]===e[9]&&t[10]===e[10]&&t[11]===e[11]&&t[12]===e[12]&&t[13]===e[13]&&t[14]===e[14]&&t[15]===e[15];var _c=Ec;const Ac=t=>(t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t);var Is=Ac;const{EPS:Sc}=I,{sin:bc,cos:Mc}=Q,Tc=Is,Fc=(t,e,n)=>{let[s,o,r]=n;const c=s*s+o*o+r*r;if(Math.abs(c)<Sc)return Tc(t);const i=1/Math.sqrt(c);s*=i,o*=i,r*=i;const l=bc(e),a=Mc(e),f=1-a;return t[0]=s*s*f+a,t[1]=o*s*f+r*l,t[2]=r*s*f-o*l,t[3]=0,t[4]=s*o*f-r*l,t[5]=o*o*f+a,t[6]=r*o*f+s*l,t[7]=0,t[8]=s*r*f+o*l,t[9]=o*r*f-s*l,t[10]=r*r*f+a,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t};var Gs=Fc;const Vc=(t,e)=>(t[0]=e[0],t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=e[1],t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=e[2],t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t);var kc=Vc;const{sin:pe,cos:de}=Q,Nc=(t,e,n,s)=>{const o=pe(e),r=de(e),c=pe(n),i=de(n),l=pe(s),a=de(s);return t[0]=i*r,t[1]=i*o,t[2]=-c,t[3]=0,t[4]=l*c*r-a*o,t[5]=a*r+l*c*o,t[6]=l*i,t[7]=0,t[8]=l*o+a*c*r,t[9]=a*c*o-l*r,t[10]=a*i,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t};var qc=Nc;const Cc=(t,e)=>(t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=e[0],t[13]=e[1],t[14]=e[2],t[15]=1,t);var Bc=Cc;const Oc=Re,zc=(t,e,n,s,o,r,c,i,l,a,f,h,p,u,d,g)=>{const y=Oc();return y[0]=t,y[1]=e,y[2]=n,y[3]=s,y[4]=o,y[5]=r,y[6]=c,y[7]=i,y[8]=l,y[9]=a,y[10]=f,y[11]=h,y[12]=p,y[13]=u,y[14]=d,y[15]=g,y};var Dc=zc;const Rc=(t,e)=>(t[0]=Math.abs(e[0]),t[1]=Math.abs(e[1]),t[2]=Math.abs(e[2]),t);var Zs=Rc;const Lc=(t,e,n)=>(t[0]=e[0]+n[0],t[1]=e[1]+n[1],t[2]=e[2]+n[2],t);var Hs=Lc;const Ic=(t,e)=>t[0]*e[0]+t[1]*e[1]+t[2]*e[2];var ee=Ic;const Gc=ee,Zc=(t,e)=>{const n=t[0],s=t[1],o=t[2],r=e[0],c=e[1],i=e[2],l=Math.sqrt(n*n+s*s+o*o),a=Math.sqrt(r*r+c*c+i*i),f=l*a,h=f&&Gc(t,e)/f;return Math.acos(Math.min(Math.max(h,-1),1))};var Hc=Zc;const Uc=()=>[0,0,0];var ne=Uc;const Xc=ne,Yc=t=>{const e=Xc();return e[0]=t[0],e[1]=t[1],e[2]=t[2],e};var Wc=Yc;const Kc=(t,e)=>(t[0]=e[0],t[1]=e[1],t[2]=e[2],t);var Us=Kc;const Qc=(t,e,n)=>{const s=e[0],o=e[1],r=e[2],c=n[0],i=n[1],l=n[2];return t[0]=o*l-r*i,t[1]=r*c-s*l,t[2]=s*i-o*c,t};var Ct=Qc;const Jc=(t,e)=>{const n=e[0]-t[0],s=e[1]-t[1],o=e[2]-t[2];return Math.sqrt(n*n+s*s+o*o)};var Xs=Jc;const jc=(t,e,n)=>(t[0]=e[0]/n[0],t[1]=e[1]/n[1],t[2]=e[2]/n[2],t);var ti=jc;const ei=(t,e)=>t[0]===e[0]&&t[1]===e[1]&&t[2]===e[2];var ni=ei;const si=(t,e)=>(t[0]=e,t[1]=e,t[2]=e,t);var oi=si;const ri=ne,ci=(t,e,n)=>{const s=ri();return s[0]=t,s[1]=e,s[2]=n,s};var ii=ci;const ai=(t,e,n=0)=>(t[0]=e[0],t[1]=e[1],t[2]=n,t);var li=ai;const fi=t=>{const e=t[0],n=t[1],s=t[2];return Math.sqrt(e*e+n*n+s*s)};var Ys=fi;const hi=(t,e,n,s)=>(t[0]=e[0]+s*(n[0]-e[0]),t[1]=e[1]+s*(n[1]-e[1]),t[2]=e[2]+s*(n[2]-e[2]),t);var pi=hi;const di=(t,e,n)=>(t[0]=Math.max(e[0],n[0]),t[1]=Math.max(e[1],n[1]),t[2]=Math.max(e[2],n[2]),t);var ui=di;const gi=(t,e,n)=>(t[0]=Math.min(e[0],n[0]),t[1]=Math.min(e[1],n[1]),t[2]=Math.min(e[2],n[2]),t);var vi=gi;const $i=(t,e,n)=>(t[0]=e[0]*n[0],t[1]=e[1]*n[1],t[2]=e[2]*n[2],t);var mi=$i;const yi=(t,e)=>(t[0]=-e[0],t[1]=-e[1],t[2]=-e[2],t);var wi=yi;const Pi=(t,e)=>{const n=e[0],s=e[1],o=e[2];let r=n*n+s*s+o*o;return r>0&&(r=1/Math.sqrt(r)),t[0]=n*r,t[1]=s*r,t[2]=o*r,t};var Le=Pi;const xi=Zs,Ei=ne,_i=Ct,Ai=(t,e)=>{const n=xi(Ei(),e),s=0+(n[0]<n[1]&&n[0]<n[2]),o=0+(n[1]<=n[0]&&n[1]<n[2]),r=0+(n[2]<=n[0]&&n[2]<=n[1]);return _i(t,e,[s,o,r])};var Si=Ai;const bi=(t,e,n,s)=>{const o=[],r=[];return o[0]=e[0]-n[0],o[1]=e[1]-n[1],o[2]=e[2]-n[2],r[0]=o[0],r[1]=o[1]*Math.cos(s)-o[2]*Math.sin(s),r[2]=o[1]*Math.sin(s)+o[2]*Math.cos(s),t[0]=r[0]+n[0],t[1]=r[1]+n[1],t[2]=r[2]+n[2],t};var Mi=bi;const Ti=(t,e,n,s)=>{const o=[],r=[];return o[0]=e[0]-n[0],o[1]=e[1]-n[1],o[2]=e[2]-n[2],r[0]=o[2]*Math.sin(s)+o[0]*Math.cos(s),r[1]=o[1],r[2]=o[2]*Math.cos(s)-o[0]*Math.sin(s),t[0]=r[0]+n[0],t[1]=r[1]+n[1],t[2]=r[2]+n[2],t};var Fi=Ti;const Vi=(t,e,n,s)=>{const o=[],r=[];return o[0]=e[0]-n[0],o[1]=e[1]-n[1],r[0]=o[0]*Math.cos(s)-o[1]*Math.sin(s),r[1]=o[0]*Math.sin(s)+o[1]*Math.cos(s),t[0]=r[0]+n[0],t[1]=r[1]+n[1],t[2]=e[2],t};var ki=Vi;const Ni=(t,e,n)=>(t[0]=e[0]*n,t[1]=e[1]*n,t[2]=e[2]*n,t);var Ws=Ni;const qi=(t,e,n)=>(t[0]=Math.round(e[0]/n)*n+0,t[1]=Math.round(e[1]/n)*n+0,t[2]=Math.round(e[2]/n)*n+0,t);var Ci=qi;const Bi=(t,e)=>{const n=e[0]-t[0],s=e[1]-t[1],o=e[2]-t[2];return n*n+s*s+o*o};var Ks=Bi;const Oi=t=>{const e=t[0],n=t[1],s=t[2];return e*e+n*n+s*s};var Qs=Oi;const zi=(t,e,n)=>(t[0]=e[0]-n[0],t[1]=e[1]-n[1],t[2]=e[2]-n[2],t);var se=zi;const Di=t=>`[${t[0].toFixed(7)}, ${t[1].toFixed(7)}, ${t[2].toFixed(7)}]`;var Ri=Di;const Li=(t,e,n)=>{const s=e[0],o=e[1],r=e[2];let c=n[3]*s+n[7]*o+n[11]*r+n[15];return c=c||1,t[0]=(n[0]*s+n[4]*o+n[8]*r+n[12])/c,t[1]=(n[1]*s+n[5]*o+n[9]*r+n[13])/c,t[2]=(n[2]*s+n[6]*o+n[10]*r+n[14])/c,t};var Ii=Li,T={abs:Zs,add:Hs,angle:Hc,clone:Wc,copy:Us,create:ne,cross:Ct,distance:Xs,divide:ti,dot:ee,equals:ni,fromScalar:oi,fromValues:ii,fromVec2:li,length:Ys,lerp:pi,max:ui,min:vi,multiply:mi,negate:wi,normalize:Le,orthogonal:Si,rotateX:Mi,rotateY:Fi,rotateZ:ki,scale:Ws,snap:Ci,squaredDistance:Ks,squaredLength:Qs,subtract:se,toString:Ri,transform:Ii};const it=T,Gi=Gs,Zi=(t,e,n)=>{const s=it.normalize(it.create(),e),o=it.normalize(it.create(),n),r=it.cross(it.create(),o,s),c=it.dot(o,s);if(c===-1)return Gi(t,Math.PI,it.orthogonal(r,s));const i=1/(1+c);return t[0]=r[0]*r[0]*i+c,t[1]=r[1]*r[0]*i-r[2],t[2]=r[2]*r[0]*i+r[1],t[3]=0,t[4]=r[0]*r[1]*i+r[2],t[5]=r[1]*r[1]*i+c,t[6]=r[2]*r[1]*i-r[0],t[7]=0,t[8]=r[0]*r[2]*i-r[1],t[9]=r[1]*r[2]*i+r[0],t[10]=r[2]*r[2]*i+c,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t};var Hi=Zi;const{sin:Ui,cos:Xi}=Q,Yi=(t,e)=>{const n=Ui(e),s=Xi(e);return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=s,t[6]=n,t[7]=0,t[8]=0,t[9]=-n,t[10]=s,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t};var Wi=Yi;const{sin:Ki,cos:Qi}=Q,Ji=(t,e)=>{const n=Ki(e),s=Qi(e);return t[0]=s,t[1]=0,t[2]=-n,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=n,t[9]=0,t[10]=s,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t};var ji=Ji;const{sin:ta,cos:ea}=Q,na=(t,e)=>{const n=ta(e),s=ea(e);return t[0]=s,t[1]=n,t[2]=0,t[3]=0,t[4]=-n,t[5]=s,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t};var sa=na;const oa=t=>t[0]===1&&t[1]===0&&t[2]===0&&t[3]===0&&t[4]===0&&t[5]===1&&t[6]===0&&t[7]===0&&t[8]===0&&t[9]===0&&t[10]===1&&t[11]===0&&t[12]===0&&t[13]===0&&t[14]===0&&t[15]===1;var ra=oa;const ca=t=>ot(t[1])&&ot(t[2])&&ot(t[3])&&ot(t[4])&&ot(t[6])&&ot(t[7])&&ot(t[8])&&ot(t[9])&&ot(t[11])&&t[15]===1,ot=t=>Math.abs(t)<Number.EPSILON;var ia=ca;const aa=t=>{const e=t[4]*t[9]-t[8]*t[5],n=t[8]*t[1]-t[0]*t[9],s=t[0]*t[5]-t[4]*t[1];return e*t[2]+n*t[6]+s*t[10]<0};var la=aa;const fa=(t,e)=>{const[n,s,o,r]=e;return t[0]=1-2*n*n,t[1]=-2*s*n,t[2]=-2*o*n,t[3]=0,t[4]=-2*n*s,t[5]=1-2*s*s,t[6]=-2*o*s,t[7]=0,t[8]=-2*n*o,t[9]=-2*s*o,t[10]=1-2*o*o,t[11]=0,t[12]=2*n*r,t[13]=2*s*r,t[14]=2*o*r,t[15]=1,t};var ha=fa;const pa=(t,e,n)=>{const s=e[0],o=e[1],r=e[2],c=e[3],i=e[4],l=e[5],a=e[6],f=e[7],h=e[8],p=e[9],u=e[10],d=e[11],g=e[12],y=e[13],M=e[14],_=e[15];let P=n[0],w=n[1],$=n[2],v=n[3];return t[0]=P*s+w*i+$*h+v*g,t[1]=P*o+w*l+$*p+v*y,t[2]=P*r+w*a+$*u+v*M,t[3]=P*c+w*f+$*d+v*_,P=n[4],w=n[5],$=n[6],v=n[7],t[4]=P*s+w*i+$*h+v*g,t[5]=P*o+w*l+$*p+v*y,t[6]=P*r+w*a+$*u+v*M,t[7]=P*c+w*f+$*d+v*_,P=n[8],w=n[9],$=n[10],v=n[11],t[8]=P*s+w*i+$*h+v*g,t[9]=P*o+w*l+$*p+v*y,t[10]=P*r+w*a+$*u+v*M,t[11]=P*c+w*f+$*d+v*_,P=n[12],w=n[13],$=n[14],v=n[15],t[12]=P*s+w*i+$*h+v*g,t[13]=P*o+w*l+$*p+v*y,t[14]=P*r+w*a+$*u+v*M,t[15]=P*c+w*f+$*d+v*_,t};var da=pa;const{EPS:ua}=I,{sin:ga,cos:va}=Q,$a=Ls,ma=(t,e,n,s)=>{let[o,r,c]=s;const i=o*o+r*r+c*c;if(Math.abs(i)<ua)return $a(t,e);const l=1/Math.sqrt(i);o*=l,r*=l,c*=l;const a=ga(n),f=va(n),h=1-f,p=e[0],u=e[1],d=e[2],g=e[3],y=e[4],M=e[5],_=e[6],P=e[7],w=e[8],$=e[9],v=e[10],m=e[11],x=o*o*h+f,A=r*o*h+c*a,E=c*o*h-r*a,S=o*r*h-c*a,V=r*r*h+f,q=c*r*h+o*a,F=o*c*h+r*a,C=r*c*h-o*a,L=c*c*h+f;return t[0]=p*x+y*A+w*E,t[1]=u*x+M*A+$*E,t[2]=d*x+_*A+v*E,t[3]=g*x+P*A+m*E,t[4]=p*S+y*V+w*q,t[5]=u*S+M*V+$*q,t[6]=d*S+_*V+v*q,t[7]=g*S+P*V+m*q,t[8]=p*F+y*C+w*L,t[9]=u*F+M*C+$*L,t[10]=d*F+_*C+v*L,t[11]=g*F+P*C+m*L,e!==t&&(t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15]),t};var ya=ma;const{sin:wa,cos:Pa}=Q,xa=(t,e,n)=>{const s=wa(n),o=Pa(n),r=e[4],c=e[5],i=e[6],l=e[7],a=e[8],f=e[9],h=e[10],p=e[11];return e!==t&&(t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15]),t[4]=r*o+a*s,t[5]=c*o+f*s,t[6]=i*o+h*s,t[7]=l*o+p*s,t[8]=a*o-r*s,t[9]=f*o-c*s,t[10]=h*o-i*s,t[11]=p*o-l*s,t};var Ea=xa;const{sin:_a,cos:Aa}=Q,Sa=(t,e,n)=>{const s=_a(n),o=Aa(n),r=e[0],c=e[1],i=e[2],l=e[3],a=e[8],f=e[9],h=e[10],p=e[11];return e!==t&&(t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15]),t[0]=r*o-a*s,t[1]=c*o-f*s,t[2]=i*o-h*s,t[3]=l*o-p*s,t[8]=r*s+a*o,t[9]=c*s+f*o,t[10]=i*s+h*o,t[11]=l*s+p*o,t};var ba=Sa;const{sin:Ma,cos:Ta}=Q,Fa=(t,e,n)=>{const s=Ma(n),o=Ta(n),r=e[0],c=e[1],i=e[2],l=e[3],a=e[4],f=e[5],h=e[6],p=e[7];return e!==t&&(t[8]=e[8],t[9]=e[9],t[10]=e[10],t[11]=e[11],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15]),t[0]=r*o+a*s,t[1]=c*o+f*s,t[2]=i*o+h*s,t[3]=l*o+p*s,t[4]=a*o-r*s,t[5]=f*o-c*s,t[6]=h*o-i*s,t[7]=p*o-l*s,t};var Va=Fa;const ka=(t,e,n)=>{const s=n[0],o=n[1],r=n[2];return t[0]=e[0]*s,t[1]=e[1]*s,t[2]=e[2]*s,t[3]=e[3]*s,t[4]=e[4]*o,t[5]=e[5]*o,t[6]=e[6]*o,t[7]=e[7]*o,t[8]=e[8]*r,t[9]=e[9]*r,t[10]=e[10]*r,t[11]=e[11]*r,t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15],t};var Na=ka;const qa=(t,e,n)=>(t[0]=e[0]-n[0],t[1]=e[1]-n[1],t[2]=e[2]-n[2],t[3]=e[3]-n[3],t[4]=e[4]-n[4],t[5]=e[5]-n[5],t[6]=e[6]-n[6],t[7]=e[7]-n[7],t[8]=e[8]-n[8],t[9]=e[9]-n[9],t[10]=e[10]-n[10],t[11]=e[11]-n[11],t[12]=e[12]-n[12],t[13]=e[13]-n[13],t[14]=e[14]-n[14],t[15]=e[15]-n[15],t);var Ca=qa;const Ba=t=>t.map(e=>e.toFixed(7)).toString();var Oa=Ba;const za=(t,e,n)=>{const s=n[0],o=n[1],r=n[2];let c,i,l,a,f,h,p,u,d,g,y,M;return e===t?(t[12]=e[0]*s+e[4]*o+e[8]*r+e[12],t[13]=e[1]*s+e[5]*o+e[9]*r+e[13],t[14]=e[2]*s+e[6]*o+e[10]*r+e[14],t[15]=e[3]*s+e[7]*o+e[11]*r+e[15]):(c=e[0],i=e[1],l=e[2],a=e[3],f=e[4],h=e[5],p=e[6],u=e[7],d=e[8],g=e[9],y=e[10],M=e[11],t[0]=c,t[1]=i,t[2]=l,t[3]=a,t[4]=f,t[5]=h,t[6]=p,t[7]=u,t[8]=d,t[9]=g,t[10]=y,t[11]=M,t[12]=c*s+f*o+d*r+e[12],t[13]=i*s+h*o+g*r+e[13],t[14]=l*s+p*o+y*r+e[14],t[15]=a*s+u*o+M*r+e[15]),t};var Da=za,D={add:gc,clone:yc,copy:Ls,create:Re,invert:xc,equals:_c,fromRotation:Gs,fromScaling:kc,fromTaitBryanRotation:qc,fromTranslation:Bc,fromValues:Dc,fromVectorRotation:Hi,fromXRotation:Wi,fromYRotation:ji,fromZRotation:sa,identity:Is,isIdentity:ra,isOnlyTransformScale:ia,isMirroring:la,mirrorByPlane:ha,multiply:da,rotate:ya,rotateX:Ea,rotateY:ba,rotateZ:Va,scale:Na,subtract:Ca,toString:Oa,translate:Da};const Ra=D,La=t=>(t===void 0&&(t=[]),{points:t,isClosed:!1,transforms:Ra.create()});var oe=La;const{EPS:an}=I,ln=k,Ia=Rs,Ga=oe,Za=(t,e)=>{const n={closed:!1};let{closed:s}=Object.assign({},n,t),o=Ga();if(o.points=e.map(r=>ln.clone(r)),o.points.length>1){const r=o.points[0],c=o.points[o.points.length-1];ln.distance(r,c)<an*an&&(s=!0)}return s===!0&&(o=Ia(o)),o};var Ie=Za;const fn=D,hn=k,Ha=t=>(fn.isIdentity(t.transforms)||(t.points=t.points.map(e=>hn.transform(hn.create(),e,t.transforms)),t.transforms=fn.create()),t);var Ua=Ha;const Xa=Ua,Ya=t=>Xa(t).points;var _t=Ya;const{TAU:Dt}=I,O=k,Wa=Ie,Ka=_t,Qa=(t,e)=>{const n={radius:[0,0],xaxisrotation:0,clockwise:!1,large:!1,segments:16};let{endpoint:s,radius:o,xaxisrotation:r,clockwise:c,large:i,segments:l}=Object.assign({},n,t);if(!Array.isArray(s))throw new Error("endpoint must be an array of X and Y values");if(s.length<2)throw new Error("endpoint must contain X and Y values");if(s=O.clone(s),!Array.isArray(o))throw new Error("radius must be an array of X and Y values");if(o.length<2)throw new Error("radius must contain X and Y values");if(l<4)throw new Error("segments must be four or more");const a=1e5;if(e.isClosed)throw new Error("the given path cannot be closed");const f=Ka(e);if(f.length<1)throw new Error("the given path must contain one or more points (as the starting point for the arc)");let h=o[0],p=o[1];const u=f[f.length-1];h=Math.round(h*a)/a,p=Math.round(p*a)/a,s=O.fromValues(Math.round(s[0]*a)/a,Math.round(s[1]*a)/a);const d=!c;let g=[];if(h===0||p===0)g.push(s);else{h=Math.abs(h),p=Math.abs(p);const M=r,_=Math.cos(M),P=Math.sin(M),w=O.subtract(O.create(),u,s);O.scale(w,w,.5);const $=Math.round((_*w[0]+P*w[1])*a)/a,v=Math.round((-P*w[0]+_*w[1])*a)/a,m=O.fromValues($,v),x=m[0]*m[0]/(h*h)+m[1]*m[1]/(p*p);if(x>1){const J=Math.sqrt(x);h*=J,p*=J,h=Math.round(h*a)/a,p=Math.round(p*a)/a}let A=Math.sqrt((h*h*p*p-h*h*m[1]*m[1]-p*p*m[0]*m[0])/(h*h*m[1]*m[1]+p*p*m[0]*m[0]));d===i&&(A=-A);const E=O.fromValues(h*m[1]/p,-p*m[0]/h);O.scale(E,E,A);let S=O.fromValues(_*E[0]-P*E[1],P*E[0]+_*E[1]);S=O.add(S,S,O.scale(O.create(),O.add(O.create(),u,s),.5));const V=O.fromValues((m[0]-E[0])/h,(m[1]-E[1])/p),q=O.fromValues((-m[0]-E[0])/h,(-m[1]-E[1])/p),F=O.angleRadians(V);let L=O.angleRadians(q)-F;L=L%Dt,!d&&L>0?L-=Dt:d&&L<0&&(L+=Dt);let et=Math.ceil(Math.abs(L)/Dt*l)+1;et<1&&(et=1);for(let J=1;J<et;J++){const sn=F+J/et*L,on=Math.cos(sn),rn=Math.sin(sn),he=O.fromValues(_*h*on-P*p*rn,P*h*on+_*p*rn);O.add(he,he,S),g.push(he)}et&&g.push(t.endpoint)}return g=f.concat(g),Wa({},g)};var Ja=Qa;const ja=Ie,tl=_t,{equals:el}=k,nl=(...t)=>{let e=!1,n=[];return t.forEach((s,o)=>{const r=tl(s).slice();if(n.length>0&&r.length>0&&el(r[0],n[n.length-1])&&r.shift(),r.length>0&&e)throw new Error(`Cannot concatenate to a closed path; check the ${o}th path`);e=s.isClosed,n=n.concat(r)}),ja({closed:e},n)};var Js=nl;const sl=Js,ol=oe,rl=(t,e)=>sl(e,ol(t));var js=rl;const{TAU:cl}=I,W=k,il=k,al=js,ll=_t,fl=(t,e)=>{const n={segments:16};let{controlPoints:s,segments:o}=Object.assign({},n,t);if(!Array.isArray(s))throw new Error("controlPoints must be an array of one or more points");if(s.length<1)throw new Error("controlPoints must be an array of one or more points");if(o<4)throw new Error("segments must be four or more");if(e.isClosed)throw new Error("the given geometry cannot be closed");const r=ll(e);if(r.length<1)throw new Error("the given path must contain one or more points (as the starting point for the bezier curve)");if(s=s.slice(),s[0]===null){if(s.length<2)throw new Error("a null control point must be passed with one more control points");let v=r[r.length-2];if("lastBezierControlPoint"in e&&(v=e.lastBezierControlPoint),!Array.isArray(v))throw new Error("the given path must contain TWO or more points if given a null control point");const m=W.scale(W.create(),r[r.length-1],2);W.subtract(m,m,v),s[0]=m}s.unshift(r[r.length-1]);const i=s.length-1,l=[];let a=1;for(let v=0;v<=i;++v)v>0&&(a*=v),l.push(a);const f=[];for(let v=0;v<=i;++v){const m=l[i]/(l[v]*l[i-v]);f.push(m)}const h=W.create(),p=W.create(),u=il.create(),d=v=>{let m=1,x=Math.pow(1-v,i);const A=v!==1?1/(1-v):1,E=W.create();for(let S=0;S<=i;++S){S===i&&(x=1);const V=f[S]*m*x,q=W.scale(h,s[S],V);W.add(E,E,q),m*=v,x*=A}return E},g=[],y=[],M=i+1;for(let v=0;v<M;++v){const m=v/(M-1),x=d(m);g.push(x),y.push(m)}let _=1;const P=cl/o,w=Math.sin(P);for(;_<g.length-1;){const v=W.subtract(h,g[_],g[_-1]);W.normalize(v,v);const m=W.subtract(p,g[_+1],g[_]);W.normalize(m,m);const x=W.cross(u,v,m);if(Math.abs(x[2])>w){const A=y[_-1],E=y[_+1],S=A+(E-A)*1/3,V=A+(E-A)*2/3,q=d(S),F=d(V);g.splice(_,1,q,F),y.splice(_,1,S,V),_--,_<1&&(_=1)}else++_}g.shift();const $=al(g,e);return $.lastBezierControlPoint=s[s.length-2],$};var hl=fl;const pl=k,pn=_t,dl=(t,e)=>{if(t.isClosed!==e.isClosed||t.points.length!==e.points.length)return!1;const n=pn(t),s=pn(e),o=n.length;let r=0;do{let c=!1;for(let i=0;i<o;i++)if(!pl.equals(n[i],s[(i+r)%o])){c=!0;break}if(c===!1)return!0;if(!t.isClosed)return!1}while(++r<o);return!1};var ul=dl;const gl=D,vl=k,$l=oe,ml=t=>{if(t[0]!==2)throw new Error("invalid compact binary data");const e=$l();e.transforms=gl.clone(t.slice(1,17)),e.isClosed=!!t[17];for(let n=22;n<t.length;n+=2){const s=vl.fromValues(t[n],t[n+1]);e.points.push(s)}return t[18]>=0&&(e.color=[t[18],t[19],t[20],t[21]]),e};var yl=ml;const wl=t=>!!(t&&typeof t=="object"&&"points"in t&&"transforms"in t&&"isClosed"in t&&Array.isArray(t.points)&&"length"in t.transforms);var to=wl;const Pl=De,xl=t=>{const e=Pl(t);return e.points=t.points.slice().reverse(),e};var El=xl;const _l=k,Al=_t,Sl=t=>{const e=Al(t);let n="path ("+e.length+" points, "+t.isClosed+`):
[
`;return e.forEach(s=>{n+="  "+_l.toString(s)+`,
`}),n+=`]
`,n};var bl=Sl;const Ml=t=>{const e=t.points,n=t.transforms;let s=[-1,-1,-1,-1];t.color&&(s=t.color);const o=new Float32Array(22+e.length*2);o[0]=2,o[1]=n[0],o[2]=n[1],o[3]=n[2],o[4]=n[3],o[5]=n[4],o[6]=n[5],o[7]=n[6],o[8]=n[7],o[9]=n[8],o[10]=n[9],o[11]=n[10],o[12]=n[11],o[13]=n[12],o[14]=n[13],o[15]=n[14],o[16]=n[15],o[17]=t.isClosed?1:0,o[18]=s[0],o[19]=s[1],o[20]=s[2],o[21]=s[3];for(let r=0;r<e.length;r++){const c=r*2+22,i=e[r];o[c]=i[0],o[c+1]=i[1]}return o};var Tl=Ml;const dn=D,Fl=(t,e)=>{const n=dn.multiply(dn.create(),t,e.transforms);return Object.assign({},e,{transforms:n})};var Vl=Fl;const kl=k,Nl=to,ql=t=>{if(!Nl(t))throw new Error("invalid path2 structure");if(t.points.length>1){for(let e=0;e<t.points.length;e++)if(kl.equals(t.points[e],t.points[(e+1)%t.points.length]))throw new Error(`path2 duplicate points ${t.points[e]}`)}if(t.points.forEach(e=>{if(!e.every(Number.isFinite))throw new Error(`path2 invalid point ${e}`)}),!t.transforms.every(Number.isFinite))throw new Error(`path2 invalid transforms ${t.transforms}`)};var Cl=ql,tt={appendArc:Ja,appendBezier:hl,appendPoints:js,clone:De,close:Rs,concat:Js,create:oe,equals:ul,fromPoints:Ie,fromCompactBinary:yl,isA:to,reverse:El,toPoints:_t,toString:bl,toCompactBinary:Tl,transform:Vl,validate:Cl};const Bl=(t,e)=>Array.isArray(t)&&t.length>=e?t.every(n=>Number.isFinite(n)):!1,Ol=(t,e)=>Number.isFinite(t)&&t>e,zl=(t,e)=>Number.isFinite(t)&&t>=e;var Bt={isNumberArray:Bl,isGT:Ol,isGTE:zl};const Dl=t=>Object.assign({},t);var Rl=Dl;const Ll=D,Il=t=>(t===void 0&&(t=[]),{sides:t,transforms:Ll.create()});var re=Il;const ue=k,Gl=re,Zl=t=>{if(!Array.isArray(t))throw new Error("the given points must be an array");let e=t.length;if(e<3)throw new Error("the given points must define a closed geometry with three or more points");ue.equals(t[0],t[e-1])&&--e;const n=[];let s=t[e-1];for(let o=0;o<e;o++){const r=t[o];n.push([ue.clone(s),ue.clone(r)]),s=r}return Gl(n)};var Hl=Zl;const Ul=D,un=k,Xl=re,Yl=t=>{if(t[0]!==0)throw new Error("invalid compact binary data");const e=Xl();e.transforms=Ul.clone(t.slice(1,17));for(let n=21;n<t.length;n+=4){const s=un.fromValues(t[n+0],t[n+1]),o=un.fromValues(t[n+2],t[n+3]);e.sides.push([s,o])}return t[17]>=0&&(e.color=[t[17],t[18],t[19],t[20]]),e};var Wl=Yl;const Kl=t=>!!(t&&typeof t=="object"&&"sides"in t&&"transforms"in t&&Array.isArray(t.sides)&&"length"in t.transforms);var eo=Kl;const gn=D,Rt=k,Ql=t=>(gn.isIdentity(t.transforms)||(t.sides=t.sides.map(e=>{const n=Rt.transform(Rt.create(),e[0],t.transforms),s=Rt.transform(Rt.create(),e[1],t.transforms);return[n,s]}),t.transforms=gn.create()),t);var Jl=Ql;const jl=Jl,t1=t=>jl(t).sides;var Ot=t1;const e1=re,n1=Ot,s1=t=>{const n=n1(t).map(s=>[s[1],s[0]]);return n.reverse(),e1(n)};var no=s1;const St=k,o1=Ot,r1=t=>{const e=new Map,n=s=>{const o=s.toString();return e.has(o)?e.get(o):(e.set(o,s),s)};return t.map(s=>s.map(n))},c1=t=>{const e=new Map;return r1(t).forEach(s=>{e.has(s[0])?e.get(s[0]).push(s):e.set(s[0],[s])}),e},i1=t=>{const e=c1(o1(t)),n=[];for(;;){let s;for(const[c,i]of e){if(s=i.shift(),!s){e.delete(c);continue}break}if(s===void 0)break;const o=[],r=s[0];for(;;){o.push(s[0]);const c=s[1];if(c===r)break;const i=e.get(c);if(!i)throw new Error(`geometry is not closed at vertex ${c}`);const l=a1(s,i);i.length===0&&e.delete(c),s=l}o.length>0&&o.push(o.shift()),n.push(o)}return e.clear(),n},a1=(t,e)=>{if(e.length===1)return e.pop();const n=St.create(),s=St.angleDegrees(St.subtract(n,t[1],t[0]));let o,r;e.forEach((i,l)=>{let f=St.angleDegrees(St.subtract(n,i[1],i[0]))-s;f<-180&&(f+=360),f>=180&&(f-=360),(r===void 0||f>o)&&(r=l,o=f)});const c=e[r];return e.splice(r,1),c};var so=i1;const l1=Ot,f1=t=>{const n=l1(t).map(s=>s[0]);return n.length>0&&n.push(n.shift()),n};var h1=f1;const vn=k,p1=Ot,d1=t=>{const e=p1(t);let n="geom2 ("+e.length+` sides):
[
`;return e.forEach(s=>{n+="  ["+vn.toString(s[0])+", "+vn.toString(s[1])+`]
`}),n+=`]
`,n};var u1=d1;const g1=t=>{const e=t.sides,n=t.transforms;let s=[-1,-1,-1,-1];t.color&&(s=t.color);const o=new Float32Array(21+e.length*4);o[0]=0,o[1]=n[0],o[2]=n[1],o[3]=n[2],o[4]=n[3],o[5]=n[4],o[6]=n[5],o[7]=n[6],o[8]=n[7],o[9]=n[8],o[10]=n[9],o[11]=n[10],o[12]=n[11],o[13]=n[12],o[14]=n[13],o[15]=n[14],o[16]=n[15],o[17]=s[0],o[18]=s[1],o[19]=s[2],o[20]=s[3];for(let r=0;r<e.length;r++){const c=r*4+21,i=e[r][0],l=e[r][1];o[c+0]=i[0],o[c+1]=i[1],o[c+2]=l[0],o[c+3]=l[1]}return o};var v1=g1;const $n=D,$1=no,m1=(t,e)=>{const n=$n.multiply($n.create(),t,e.transforms),s=Object.assign({},e,{transforms:n});return t[0]*t[5]-t[4]*t[1]<0?$1(s):s};var y1=m1;const w1=k,P1=eo,x1=so,E1=t=>{if(!P1(t))throw new Error("invalid geom2 structure");if(x1(t),t.sides.forEach(e=>{if(w1.equals(e[0],e[1]))throw new Error(`geom2 self-edge ${e[0]}`)}),!t.transforms.every(Number.isFinite))throw new Error(`geom2 invalid transforms ${t.transforms}`)};var _1=E1,R={clone:Rl,create:re,fromPoints:Hl,fromCompactBinary:Wl,isA:eo,reverse:no,toOutlines:so,toPoints:h1,toSides:Ot,toString:u1,toCompactBinary:v1,transform:y1,validate:_1};const A1=t=>Object.assign({},t);var S1=A1;const b1=D,M1=t=>(t===void 0&&(t=[]),{polygons:t,transforms:b1.create()});var zt=M1;const T1=Ct,mn=se,yn=Qs,F1=(t,e,n)=>{const s=[],o=[],r=[];mn(s,n,e),mn(o,t,e);const c=yn(T1(r,o,s)),i=yn(s);if(i===0)throw Error("a and b are the same point");return c/i},V1=(t,e,n)=>Math.sqrt(F1(t,e,n));var k1=V1;const N1=Ct,q1=Le,wn=se,C1=(t,e,n,s)=>{const o=[0,0,0];return wn(t,e,n),wn(o,n,s),N1(t,t,o),q1(t,t)};var B1=C1;let O1=class{constructor(){this.head=null,this.tail=null}clear(){this.head=this.tail=null}insertBefore(e,n){n.prev=e.prev,n.next=e,n.prev?n.prev.next=n:this.head=n,e.prev=n}insertAfter(e,n){n.prev=e,n.next=e.next,n.next?n.next.prev=n:this.tail=n,e.next=n}add(e){this.head?this.tail.next=e:this.head=e,e.prev=this.tail,e.next=null,this.tail=e}addAll(e){for(this.head?this.tail.next=e:this.head=e,e.prev=this.tail;e.next;)e=e.next;this.tail=e}remove(e){e.prev?e.prev.next=e.next:this.head=e.next,e.next?e.next.prev=e.prev:this.tail=e.prev}removeChain(e,n){e.prev?e.prev.next=n.next:this.head=n.next,n.next?n.next.prev=e.prev:this.tail=e.prev}first(){return this.head}isEmpty(){return!this.head}};var z1=O1;let D1=class{constructor(e,n){this.point=e,this.index=n,this.next=null,this.prev=null,this.face=null}};var R1=D1;const L1=Xs,I1=Ks;let G1=class{constructor(e,n){this.vertex=e,this.face=n,this.next=null,this.prev=null,this.opposite=null}head(){return this.vertex}tail(){return this.prev?this.prev.vertex:null}length(){return this.tail()?L1(this.tail().point,this.head().point):-1}lengthSquared(){return this.tail()?I1(this.tail().point,this.head().point):-1}setOpposite(e){this.opposite=e,e.opposite=this}};var Z1=G1;const ge=Hs,H1=Us,U1=Ct,ve=ee,X1=Ys,Y1=Le,Lt=Ws,$e=se,me=Z1,oo=0,W1=1,ke=2;let K1=class ro{constructor(){this.normal=[],this.centroid=[],this.offset=0,this.outside=null,this.mark=oo,this.edge=null,this.nVertices=0}getEdge(e){if(typeof e!="number")throw Error("requires a number");let n=this.edge;for(;e>0;)n=n.next,e-=1;for(;e<0;)n=n.prev,e+=1;return n}computeNormal(){const e=this.edge,n=e.next;let s=n.next;const o=$e([],n.head().point,e.head().point),r=[],c=[];for(this.nVertices=2,this.normal=[0,0,0];s!==e;)H1(c,o),$e(o,s.head().point,e.head().point),ge(this.normal,this.normal,U1(r,c,o)),s=s.next,this.nVertices+=1;this.area=X1(this.normal),this.normal=Lt(this.normal,this.normal,1/this.area)}computeNormalMinArea(e){if(this.computeNormal(),this.area<e){let n,s=0,o=this.edge;do{const f=o.lengthSquared();f>s&&(n=o,s=f),o=o.next}while(o!==this.edge);const r=n.tail().point,c=n.head().point,i=$e([],c,r),l=Math.sqrt(s);Lt(i,i,1/l);const a=ve(this.normal,i);Lt(i,i,-a),ge(this.normal,this.normal,i),Y1(this.normal,this.normal)}}computeCentroid(){this.centroid=[0,0,0];let e=this.edge;do ge(this.centroid,this.centroid,e.head().point),e=e.next;while(e!==this.edge);Lt(this.centroid,this.centroid,1/this.nVertices)}computeNormalAndCentroid(e){typeof e<"u"?this.computeNormalMinArea(e):this.computeNormal(),this.computeCentroid(),this.offset=ve(this.normal,this.centroid)}distanceToPlane(e){return ve(this.normal,e)-this.offset}connectHalfEdges(e,n){let s;if(e.opposite.face===n.opposite.face){const o=n.opposite.face;let r;e===this.edge&&(this.edge=n),o.nVertices===3?(r=n.opposite.prev.opposite,o.mark=ke,s=o):(r=n.opposite.next,o.edge===r.prev&&(o.edge=r),r.prev=r.prev.prev,r.prev.next=r),n.prev=e.prev,n.prev.next=n,n.setOpposite(r),o.computeNormalAndCentroid()}else e.next=n,n.prev=e;return s}mergeAdjacentFaces(e,n){const s=e.opposite,o=s.face;n.push(o),o.mark=ke;let r=e.prev,c=e.next,i=s.prev,l=s.next;for(;r.opposite.face===o;)r=r.prev,l=l.next;for(;c.opposite.face===o;)c=c.next,i=i.prev;let a;for(a=l;a!==i.next;a=a.next)a.face=this;this.edge=c;let f;return f=this.connectHalfEdges(i,c),f&&n.push(f),f=this.connectHalfEdges(r,l),f&&n.push(f),this.computeNormalAndCentroid(),n}collectIndices(){const e=[];let n=this.edge;do e.push(n.head().index),n=n.next;while(n!==this.edge);return e}static createTriangle(e,n,s,o=0){const r=new ro,c=new me(e,r),i=new me(n,r),l=new me(s,r);return c.next=l.prev=i,i.next=c.prev=l,l.next=i.prev=c,r.edge=c,r.computeNormalAndCentroid(o),r}};var Q1={VISIBLE:oo,NON_CONVEX:W1,DELETED:ke,Face:K1};const ye=ee,J1=k1,j1=B1,Pn=z1,tf=R1,{Face:rt,VISIBLE:$t,NON_CONVEX:xn,DELETED:ef}=Q1,nf=1,En=2;let sf=class{constructor(e){if(!Array.isArray(e))throw TypeError("input is not a valid array");if(e.length<4)throw Error("cannot build a simplex out of <4 points");this.tolerance=-1,this.nFaces=0,this.nPoints=e.length,this.faces=[],this.newFaces=[],this.claimed=new Pn,this.unclaimed=new Pn,this.vertices=[];for(let n=0;n<e.length;n+=1)this.vertices.push(new tf(e[n],n));this.discardedFaces=[],this.vertexPointIndices=[]}addVertexToFace(e,n){e.face=n,n.outside?this.claimed.insertBefore(n.outside,e):this.claimed.add(e),n.outside=e}removeVertexFromFace(e,n){e===n.outside&&(e.next&&e.next.face===n?n.outside=e.next:n.outside=null),this.claimed.remove(e)}removeAllVerticesFromFace(e){if(e.outside){let n=e.outside;for(;n.next&&n.next.face===e;)n=n.next;return this.claimed.removeChain(e.outside,n),n.next=null,e.outside}}deleteFaceVertices(e,n){const s=this.removeAllVerticesFromFace(e);if(s)if(!n)this.unclaimed.addAll(s);else{let o;for(let r=s;r;r=o)o=r.next,n.distanceToPlane(r.point)>this.tolerance?this.addVertexToFace(r,n):this.unclaimed.add(r)}}resolveUnclaimedPoints(e){let n=this.unclaimed.first();for(let s=n;s;s=n){n=s.next;let o=this.tolerance,r;for(let c=0;c<e.length;c+=1){const i=e[c];if(i.mark===$t){const l=i.distanceToPlane(s.point);if(l>o&&(o=l,r=i),o>1e3*this.tolerance)break}}r&&this.addVertexToFace(s,r)}}computeExtremes(){const e=[],n=[],s=[],o=[];let r,c;for(r=0;r<3;r+=1)s[r]=o[r]=this.vertices[0];for(r=0;r<3;r+=1)e[r]=n[r]=this.vertices[0].point[r];for(r=1;r<this.vertices.length;r+=1){const i=this.vertices[r],l=i.point;for(c=0;c<3;c+=1)l[c]<e[c]&&(e[c]=l[c],s[c]=i);for(c=0;c<3;c+=1)l[c]>n[c]&&(n[c]=l[c],o[c]=i)}return this.tolerance=3*Number.EPSILON*(Math.max(Math.abs(e[0]),Math.abs(n[0]))+Math.max(Math.abs(e[1]),Math.abs(n[1]))+Math.max(Math.abs(e[2]),Math.abs(n[2]))),[s,o]}createInitialSimplex(){const e=this.vertices,[n,s]=this.computeExtremes();let o,r,c,i,l=0,a=0;for(c=0;c<3;c+=1){const g=s[c].point[c]-n[c].point[c];g>l&&(l=g,a=c)}const f=n[a],h=s[a];for(l=0,c=0;c<this.vertices.length;c+=1){const g=this.vertices[c];if(g!==f&&g!==h){const y=J1(g.point,f.point,h.point);y>l&&(l=y,o=g)}}const p=j1([],f.point,h.point,o.point),u=ye(f.point,p);for(l=-1,c=0;c<this.vertices.length;c+=1){const g=this.vertices[c];if(g!==f&&g!==h&&g!==o){const y=Math.abs(ye(p,g.point)-u);y>l&&(l=y,r=g)}}const d=[];if(ye(r.point,p)-u<0)for(d.push(rt.createTriangle(f,h,o),rt.createTriangle(r,h,f),rt.createTriangle(r,o,h),rt.createTriangle(r,f,o)),c=0;c<3;c+=1){const g=(c+1)%3;d[c+1].getEdge(2).setOpposite(d[0].getEdge(g)),d[c+1].getEdge(1).setOpposite(d[g+1].getEdge(0))}else for(d.push(rt.createTriangle(f,o,h),rt.createTriangle(r,f,h),rt.createTriangle(r,h,o),rt.createTriangle(r,o,f)),c=0;c<3;c+=1){const g=(c+1)%3;d[c+1].getEdge(2).setOpposite(d[0].getEdge((3-c)%3)),d[c+1].getEdge(0).setOpposite(d[g+1].getEdge(1))}for(c=0;c<4;c+=1)this.faces.push(d[c]);for(c=0;c<e.length;c+=1){const g=e[c];if(g!==f&&g!==h&&g!==o&&g!==r){l=this.tolerance;let y;for(i=0;i<4;i+=1){const M=d[i].distanceToPlane(g.point);M>l&&(l=M,y=d[i])}y&&this.addVertexToFace(g,y)}}}reindexFaceAndVertices(){const e=[];for(let n=0;n<this.faces.length;n+=1){const s=this.faces[n];s.mark===$t&&e.push(s)}this.faces=e}collectFaces(e){const n=[];for(let s=0;s<this.faces.length;s+=1){if(this.faces[s].mark!==$t)throw Error("attempt to include a destroyed face in the hull");const o=this.faces[s].collectIndices();if(e)n.push(o);else for(let r=0;r<o.length-2;r+=1)n.push([o[0],o[r+1],o[r+2]])}return n}nextVertexToAdd(){if(!this.claimed.isEmpty()){let e,n,s=0;const o=this.claimed.first().face;for(n=o.outside;n&&n.face===o;n=n.next){const r=o.distanceToPlane(n.point);r>s&&(s=r,e=n)}return e}}computeHorizon(e,n,s,o){this.deleteFaceVertices(s),s.mark=ef;let r;n?r=n.next:r=n=s.getEdge(0);do{const c=r.opposite,i=c.face;i.mark===$t&&(i.distanceToPlane(e)>this.tolerance?this.computeHorizon(e,c,i,o):o.push(r)),r=r.next}while(r!==n)}addAdjoiningFace(e,n){const s=rt.createTriangle(e,n.tail(),n.head());return this.faces.push(s),s.getEdge(-1).setOpposite(n.opposite),s.getEdge(0)}addNewFaces(e,n){this.newFaces=[];let s,o;for(let r=0;r<n.length;r+=1){const c=n[r],i=this.addAdjoiningFace(e,c);s?i.next.setOpposite(o):s=i,this.newFaces.push(i.face),o=i}s.next.setOpposite(o)}oppositeFaceDistance(e){return e.face.distanceToPlane(e.opposite.face.centroid)}doAdjacentMerge(e,n){let s=e.edge,o=!0,r=0;do{if(r>=e.nVertices)throw Error("merge recursion limit exceeded");const c=s.opposite.face;let i=!1;if(n===En?(this.oppositeFaceDistance(s)>-this.tolerance||this.oppositeFaceDistance(s.opposite)>-this.tolerance)&&(i=!0):e.area>c.area?this.oppositeFaceDistance(s)>-this.tolerance?i=!0:this.oppositeFaceDistance(s.opposite)>-this.tolerance&&(o=!1):this.oppositeFaceDistance(s.opposite)>-this.tolerance?i=!0:this.oppositeFaceDistance(s)>-this.tolerance&&(o=!1),i){const l=e.mergeAdjacentFaces(s,[]);for(let a=0;a<l.length;a+=1)this.deleteFaceVertices(l[a],e);return!0}s=s.next,r+=1}while(s!==e.edge);return o||(e.mark=xn),!1}addVertexToHull(e){const n=[];this.unclaimed.clear(),this.removeVertexFromFace(e,e.face),this.computeHorizon(e.point,null,e.face,n),this.addNewFaces(e,n);for(let s=0;s<this.newFaces.length;s+=1){const o=this.newFaces[s];if(o.mark===$t)for(;this.doAdjacentMerge(o,nf););}for(let s=0;s<this.newFaces.length;s+=1){const o=this.newFaces[s];if(o.mark===xn)for(o.mark=$t;this.doAdjacentMerge(o,En););}this.resolveUnclaimedPoints(this.newFaces)}build(){let e;for(this.createInitialSimplex();e=this.nextVertexToAdd();)this.addVertexToHull(e);this.reindexFaceAndVertices()}};var of=sf;const rf=of,cf=(t,e={})=>{const n=new rf(t);return n.build(),n.collectFaces(e.skipTriangulation)};var co=cf;const af=t=>((t===void 0||t.length<3)&&(t=[]),{vertices:t});var At=af;const lf=At,ff=T,hf=(...t)=>{let e,n;return t.length===1?(e=lf(),n=t[0]):(e=t[0],n=t[1]),e.vertices=n.vertices.map(s=>ff.clone(s)),e};var pf=hf;const df=T,uf=At,gf=t=>{const e=t.map(n=>df.clone(n));return uf(e)};var vf=gf;const $f=At,mf=(t,e)=>{const n=$f(t);return n.plane=e,n};var yf=mf;const wf=()=>[0,0,0,0];var ce=wf;const Pf=ce,xf=t=>{const e=Pf();return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e};var io=xf;const Ef=(t,e)=>(t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t);var ao=Ef;const _f=(t,e)=>t[0]===e[0]&&t[1]===e[1]&&t[2]===e[2]&&t[3]===e[3];var lo=_f;const Af=(t,e)=>(t[0]=-e[0],t[1]=-e[1],t[2]=-e[2],t[3]=-e[3],t);var fo=Af;const we=T,Sf=(t,e,n)=>{const s=we.normalize(we.create(),e),o=we.dot(n,s);return t[0]=s[0],t[1]=s[1],t[2]=s[2],t[3]=o,t};var ho=Sf;const bf=ce,Mf=(t,e,n,s)=>{const o=bf();return o[0]=t,o[1]=e,o[2]=n,o[3]=s,o};var po=Mf;const K=T,Tf=ho,Ff=(t,...e)=>{t[0]=0,t[1]=0,t[2]=0,t[3]=0;const n=e.length;e.forEach(u=>{K.add(t,t,u)}),K.scale(t,t,1/n);let s=0,o=0,r=0,c=0,i=0,l=0;const a=K.create();e.forEach(u=>{K.subtract(a,u,t),s+=a[0]*a[0],o+=a[0]*a[1],r+=a[0]*a[2],c+=a[1]*a[1],i+=a[1]*a[2],l+=a[2]*a[2]}),s/=n,o/=n,r/=n,c/=n,i/=n,l/=n,a[0]=0,a[1]=0,a[2]=0;const f=K.create();let h=c*l-i*i;f[0]=h,f[1]=r*i-o*l,f[2]=o*i-r*c;let p=h*h;return K.add(a,a,K.scale(f,f,p)),h=s*l-r*r,f[0]=r*i-o*l,f[1]=h,f[2]=o*r-i*s,p=h*h,K.dot(a,f)<0&&(p=-p),K.add(a,a,K.scale(f,f,p)),h=s*c-o*o,f[0]=o*i-r*c,f[1]=o*r-i*s,f[2]=h,p=h*h,K.dot(a,f)<0&&(p=-p),K.add(a,a,K.scale(f,f,p)),Tf(t,a,t)};var Vf=Ff;const nt=T,kf=(t,...e)=>{const n=e.length,s=nt.create(),o=nt.create(),r=c=>{const i=e[c],l=e[(c+1)%n],a=e[(c+2)%n];return nt.subtract(s,l,i),nt.subtract(o,a,i),nt.cross(s,s,o),nt.normalize(s,s),s};return t[0]=0,t[1]=0,t[2]=0,n===3?nt.copy(t,r(0)):(e.forEach((c,i)=>{nt.add(t,t,r(i))}),nt.normalize(t,t)),t[3]=nt.dot(t,e[0]),t};var uo=kf;const{EPS:Pe}=I,U=T,Nf=(t,e,n,s)=>{let o=U.subtract(U.create(),n,e),r=U.subtract(U.create(),s,e);U.length(o)<Pe&&(o=U.orthogonal(o,r)),U.length(r)<Pe&&(r=U.orthogonal(r,o));let c=U.cross(U.create(),o,r);U.length(c)<Pe&&(r=U.orthogonal(r,o),c=U.cross(c,o,r)),c=U.normalize(c,c);const i=U.dot(c,e);return t[0]=c[0],t[1]=c[1],t[2]=c[2],t[3]=i,t};var qf=Nf;const Cf=T,Bf=(t,e)=>{const n=e[0]*t[0]+e[1]*t[1]+e[2]*t[2]-t[3],s=e[0]-n*t[0],o=e[1]-n*t[1],r=e[2]-n*t[2];return Cf.fromValues(s,o,r)};var Of=Bf;const zf=T,Df=(t,e)=>zf.dot(t,e)-t[3];var go=Df;const Rf=t=>`(${t[0].toFixed(9)}, ${t[1].toFixed(9)}, ${t[2].toFixed(9)}, ${t[3].toFixed(9)})`;var vo=Rf;const Lf=D,X=T,If=uo,Gf=fo,Zf=(t,e,n)=>{const s=Lf.isMirroring(n),o=X.orthogonal(X.create(),e),r=X.cross(o,e,o),c=X.cross(X.create(),e,r);let i=X.fromScalar(X.create(),e[3]);X.multiply(i,i,e);let l=X.add(X.create(),i,r),a=X.add(X.create(),i,c);return i=X.transform(i,i,n),l=X.transform(l,l,n),a=X.transform(a,a,n),If(t,i,l,a),s&&Gf(t,t),t};var Hf=Zf,gt={clone:io,copy:ao,create:ce,equals:lo,flip:fo,fromNormalAndPoint:ho,fromValues:po,fromNoisyPoints:Vf,fromPoints:uo,fromPointsRandom:qf,projectionOfPoint:Of,signedDistanceToPoint:go,toString:vo,transform:Hf};const _n=gt,Uf=At,Xf=t=>{const e=t.vertices.slice().reverse(),n=Uf(e);return t.plane&&(n.plane=_n.flip(_n.create(),t.plane)),n};var Yf=Xf;const Wf=t=>!!(t&&typeof t=="object"&&"vertices"in t&&Array.isArray(t.vertices));var $o=Wf;const An=gt,pt=T,Kf=t=>Qf(t.vertices),Qf=t=>{const e=t.length;if(e>2){const n=An.fromPoints(An.create(),...t);let s=t[e-2],o=t[e-1];for(let r=0;r<e;r++){const c=t[r];if(!Jf(s,o,c,n))return!1;s=o,o=c}}return!0},Jf=(t,e,n,s)=>{const o=pt.cross(pt.create(),pt.subtract(pt.create(),e,t),pt.subtract(pt.create(),n,e));return pt.dot(o,s)>=0};var mo=Kf;const Sn=gt,jf=t=>(t.plane||(t.plane=Sn.fromPoints(Sn.create(),...t.vertices)),t.plane);var Ge=jf;const th=Ge,eh=t=>{const e=t.vertices.length;if(e<3)return 0;const n=t.vertices,s=th(t),o=Math.abs(s[0]),r=Math.abs(s[1]),c=Math.abs(s[2]);if(o+r+c===0)return 0;let i=3;o>r&&o>c?i=1:r>c&&(i=2);let l=0,a=0,f=1,h=2;switch(i){case 1:for(f=1;f<e;f++)a=f-1,h=(f+1)%e,l+=n[f][1]*(n[h][2]-n[a][2]);l+=n[0][1]*(n[1][2]-n[e-1][2]),l/=2*s[0];break;case 2:for(f=1;f<e;f++)a=f-1,h=(f+1)%e,l+=n[f][2]*(n[h][0]-n[a][0]);l+=n[0][2]*(n[1][0]-n[e-1][0]),l/=2*s[1];break;case 3:default:for(f=1;f<e;f++)a=f-1,h=(f+1)%e,l+=n[f][0]*(n[h][1]-n[a][1]);l+=n[0][0]*(n[1][1]-n[e-1][1]),l/=2*s[2];break}return l};var yo=eh;const bt=T,nh=t=>{const e=t.vertices,n=e.length,s=n===0?bt.create():bt.clone(e[0]),o=bt.clone(s);for(let r=1;r<n;r++)bt.min(s,s,e[r]),bt.max(o,o,e[r]);return[s,o]};var sh=nh;const oh=(t,e)=>t[0]*e[0]+t[1]*e[1]+t[2]*e[2]+t[3]*e[3];var rh=oh;const ch=(t,e)=>(t[0]=e,t[1]=e,t[2]=e,t[3]=e,t);var ih=ch;const ah=(t,e,n)=>{const[s,o,r,c]=e;return t[0]=n[0]*s+n[4]*o+n[8]*r+n[12]*c,t[1]=n[1]*s+n[5]*o+n[9]*r+n[13]*c,t[2]=n[2]*s+n[6]*o+n[10]*r+n[14]*c,t[3]=n[3]*s+n[7]*o+n[11]*r+n[15]*c,t};var lh=ah,fh={clone:io,copy:ao,create:ce,dot:rh,equals:lo,fromScalar:ih,fromValues:po,toString:vo,transform:lh};const hh=fh,bn=new WeakMap,ph=t=>{const e=bn.get(t);if(e)return e;const n=t.vertices,s=hh.create();if(n.length===0)return s[0]=0,s[1]=0,s[2]=0,s[3]=0,s;let o=n[0],r=o,c=o,i=o,l=o,a=o;n.forEach(u=>{o[0]>u[0]&&(o=u),r[1]>u[1]&&(r=u),c[2]>u[2]&&(c=u),i[0]<u[0]&&(i=u),l[1]<u[1]&&(l=u),a[2]<u[2]&&(a=u)}),s[0]=(o[0]+i[0])*.5,s[1]=(r[1]+l[1])*.5,s[2]=(c[2]+a[2])*.5;const f=s[0]-i[0],h=s[1]-l[1],p=s[2]-a[2];return s[3]=Math.sqrt(f*f+h*h+p*p),bn.set(t,s),s};var dh=ph;const xe=T,uh=t=>{let e=0;const n=t.vertices,s=xe.create();for(let o=0;o<n.length-2;o++)xe.cross(s,n[o+1],n[o+2]),e+=xe.dot(n[0],s);return e/=6,e};var gh=uh;const vh=t=>t.vertices;var $h=vh;const mh=T,yh=t=>{let e="poly3: vertices: [";return t.vertices.forEach(n=>{e+=`${mh.toString(n)}, `}),e+="]",e};var wh=yh;const Ph=D,Mn=T,xh=At,Eh=(t,e)=>{const n=e.vertices.map(s=>Mn.transform(Mn.create(),s,t));return Ph.isMirroring(t)&&n.reverse(),xh(n)};var _h=Eh;const Ah=go,{NEPS:Sh}=I,bh=T,Mh=$o,Th=mo,Fh=yo,Vh=Ge,kh=t=>{if(!Mh(t))throw new Error("invalid poly3 structure");if(t.vertices.length<3)throw new Error(`poly3 not enough vertices ${t.vertices.length}`);if(Fh(t)<=0)throw new Error("poly3 area must be greater than zero");for(let e=0;e<t.vertices.length;e++)if(bh.equals(t.vertices[e],t.vertices[(e+1)%t.vertices.length]))throw new Error(`poly3 duplicate vertex ${t.vertices[e]}`);if(!Th(t))throw new Error("poly3 must be convex");if(t.vertices.forEach(e=>{if(!e.every(Number.isFinite))throw new Error(`poly3 invalid vertex ${e}`)}),t.vertices.length>3){const e=Vh(t);t.vertices.forEach(n=>{const s=Math.abs(Ah(e,n));if(s>Sh)throw new Error(`poly3 must be coplanar: vertex ${n} distance ${s}`)})}};var Nh=kh,B={clone:pf,create:At,fromPoints:vf,fromPointsAndPlane:yf,invert:Yf,isA:$o,isConvex:mo,measureArea:yo,measureBoundingBox:sh,measureBoundingSphere:dh,measureSignedVolume:gh,plane:Ge,toPoints:$h,toString:wh,transform:_h,validate:Nh};const qh=co,Ch=zt,Bh=B,Oh=t=>{if(!Array.isArray(t))throw new Error("the given points must be an array");const n=qh(t,{skipTriangulation:!0}).map(s=>{const o=s.map(r=>t[r]);return Bh.create(o)});return Ch(n)};var zh=Oh;const Dh=B,Rh=zt,Lh=t=>{if(!Array.isArray(t))throw new Error("the given points must be an array");const e=t.map((s,o)=>Dh.create(s));return Rh(e)};var Ih=Lh;const Gh=T,Zh=D,Hh=B,Uh=zt,Xh=t=>{if(t[0]!==1)throw new Error("invalid compact binary data");const e=Uh();e.transforms=Zh.clone(t.slice(1,17));const n=t[21];let s=22,o=t.length-n*3;for(;o<t.length;){const r=t[s];s++;const c=[];for(let i=0;i<r;i++)c.push(Gh.fromValues(t[o],t[o+1],t[o+2])),o+=3;e.polygons.push(Hh.create(c))}return t[17]>=0&&(e.color=[t[17],t[18],t[19],t[20]]),e};var Yh=Xh;const Tn=D,Wh=B,Kh=t=>(Tn.isIdentity(t.transforms)||(t.polygons=t.polygons.map(e=>Wh.transform(t.transforms,e)),t.transforms=Tn.create()),t);var Qh=Kh;const Jh=Qh,jh=t=>Jh(t).polygons;var ie=jh;const t0=B,e0=zt,n0=ie,s0=t=>{const n=n0(t).map(s=>t0.invert(s));return e0(n)};var o0=s0;const r0=t=>!!(t&&typeof t=="object"&&"polygons"in t&&"transforms"in t&&Array.isArray(t.polygons)&&"length"in t.transforms);var wo=r0;const c0=B,i0=ie,a0=t=>i0(t).map(s=>c0.toPoints(s));var l0=a0;const f0=B,h0=ie,p0=t=>{const e=h0(t);let n="geom3 ("+e.length+` polygons):
`;return e.forEach(s=>{n+="  "+f0.toString(s)+`
`}),n};var d0=p0;const u0=B,g0=t=>{const e=t.polygons,n=t.transforms,s=e.length,o=e.reduce((a,f)=>a+f.vertices.length,0);let r=[-1,-1,-1,-1];t.color&&(r=t.color);const c=new Float32Array(22+s+o*3);c[0]=1,c[1]=n[0],c[2]=n[1],c[3]=n[2],c[4]=n[3],c[5]=n[4],c[6]=n[5],c[7]=n[6],c[8]=n[7],c[9]=n[8],c[10]=n[9],c[11]=n[10],c[12]=n[11],c[13]=n[12],c[14]=n[13],c[15]=n[14],c[16]=n[15],c[17]=r[0],c[18]=r[1],c[19]=r[2],c[20]=r[3],c[21]=o;let i=22,l=i+s;return e.forEach(a=>{const f=u0.toPoints(a);c[i]=f.length,i++;for(let h=0;h<f.length;h++){const p=f[h];c[l+0]=p[0],c[l+1]=p[1],c[l+2]=p[2],l+=3}}),c};var v0=g0;const Fn=D,$0=(t,e)=>{const n=Fn.multiply(Fn.create(),t,e.transforms);return Object.assign({},e,{transforms:n})};var m0=$0;const y0=B,w0=wo,P0=t=>{if(!w0(t))throw new Error("invalid geom3 structure");if(t.polygons.forEach(y0.validate),x0(t),!t.transforms.every(Number.isFinite))throw new Error(`geom3 invalid transforms ${t.transforms}`)},x0=t=>{const e=new Map;t.polygons.forEach(({vertices:s})=>{s.forEach((o,r)=>{const c=`${o}`,i=`${s[(r+1)%s.length]}`,l=`${c}/${i}`,a=e.has(l)?e.get(l):0;e.set(l,a+1)})});const n=[];if(e.forEach((s,o)=>{const r=o.split("/").reverse().join("/"),c=e.get(r);s!==c&&n.push(o.replace("/"," -> "))}),n.length>0)throw new Error(`non-manifold edges ${n.length}
${n.join(`
`)}`)};var E0=P0,N={clone:S1,create:zt,fromPointsConvex:zh,fromPoints:Ih,fromCompactBinary:Yh,invert:o0,isA:wo,toPoints:l0,toPolygons:ie,toString:d0,toCompactBinary:v0,transform:m0,validate:E0};const Vn=N,_0=B,{isNumberArray:kn}=Bt,A0=t=>{const e={center:[0,0,0],size:[2,2,2]},{center:n,size:s}=Object.assign({},e,t);if(!kn(n,3))throw new Error("center must be an array of X, Y and Z values");if(!kn(s,3))throw new Error("size must be an array of width, depth and height values");if(!s.every(r=>r>=0))throw new Error("size values must be positive");return s[0]===0||s[1]===0||s[2]===0?Vn.create():Vn.create([[[0,4,6,2],[-1,0,0]],[[1,3,7,5],[1,0,0]],[[0,1,5,4],[0,-1,0]],[[2,6,7,3],[0,1,0]],[[0,2,3,1],[0,0,-1]],[[4,5,7,6],[0,0,1]]].map(r=>{const c=r[0].map(i=>[n[0]+s[0]/2*(2*!!(i&1)-1),n[1]+s[1]/2*(2*!!(i&2)-1),n[2]+s[2]/2*(2*!!(i&4)-1)]);return _0.create(c)}))};var S0=A0;const{EPS:Nn,TAU:at}=I,Z=T,b0=N,M0=B,{sin:T0,cos:F0}=Q,{isGT:V0,isGTE:Ee,isNumberArray:_e}=Bt,k0=t=>{const e={center:[0,0,0],height:2,startRadius:[1,1],startAngle:0,endRadius:[1,1],endAngle:at,segments:32};let{center:n,height:s,startRadius:o,startAngle:r,endRadius:c,endAngle:i,segments:l}=Object.assign({},e,t);if(!_e(n,3))throw new Error("center must be an array of X, Y and Z values");if(!V0(s,0))throw new Error("height must be greater then zero");if(!_e(o,2))throw new Error("startRadius must be an array of X and Y values");if(!o.every(A=>A>=0))throw new Error("startRadius values must be positive");if(!_e(c,2))throw new Error("endRadius must be an array of X and Y values");if(!c.every(A=>A>=0))throw new Error("endRadius values must be positive");if(c.every(A=>A===0)&&o.every(A=>A===0))throw new Error("at least one radius must be positive");if(!Ee(r,0))throw new Error("startAngle must be positive");if(!Ee(i,0))throw new Error("endAngle must be positive");if(!Ee(l,4))throw new Error("segments must be four or more");r=r%at,i=i%at;let a=at;r<i&&(a=i-r),r>i&&(a=i+(at-r));const f=Math.min(o[0],o[1],c[0],c[1]),h=Math.acos((f*f+f*f-Nn*Nn)/(2*f*f));if(a<h)throw new Error("startAngle and endAngle do not define a significant rotation");const p=Math.floor(l*(a/at)),u=Z.fromValues(0,0,-(s/2)),d=Z.fromValues(0,0,s/2),g=Z.subtract(Z.create(),d,u),y=Z.fromValues(1,0,0),M=Z.fromValues(0,1,0),_=Z.create(),P=Z.create(),w=Z.create(),$=(A,E,S)=>{const V=E*a+r;return Z.scale(_,y,S[0]*F0(V)),Z.scale(P,M,S[1]*T0(V)),Z.add(_,_,P),Z.scale(w,g,A),Z.add(w,w,u),Z.add(Z.create(),_,w)},v=(...A)=>{const E=A.map(S=>Z.add(Z.create(),S,n));return M0.create(E)},m=[];for(let A=0;A<p;A++){const E=A/p;let S=(A+1)/p;a===at&&A===p-1&&(S=0),c[0]===o[0]&&c[1]===o[1]?(m.push(v(u,$(0,S,c),$(0,E,c))),m.push(v($(0,S,c),$(1,S,c),$(1,E,c),$(0,E,c))),m.push(v(d,$(1,E,c),$(1,S,c)))):(o[0]>0&&o[1]>0&&m.push(v(u,$(0,S,o),$(0,E,o))),(o[0]>0||o[1]>0)&&m.push(v($(0,E,o),$(0,S,o),$(1,E,c))),c[0]>0&&c[1]>0&&m.push(v(d,$(1,E,c),$(1,S,c))),(c[0]>0||c[1]>0)&&m.push(v($(1,E,c),$(0,S,o),$(1,S,c))))}return a<at&&(m.push(v(u,$(0,0,o),d)),m.push(v($(0,0,o),$(1,0,c),d)),m.push(v(u,d,$(0,1,o))),m.push(v($(0,1,o),d,$(1,1,c)))),b0.create(m)};var N0=k0;const q0=N,C0=N0,{isGTE:B0}=Bt,O0=t=>{const e={center:[0,0,0],height:2,radius:1,segments:32},{center:n,height:s,radius:o,segments:r}=Object.assign({},e,t);if(!B0(o,0))throw new Error("radius must be positive");return s===0||o===0?q0.create():C0({center:n,height:s,startRadius:[o,o],endRadius:[o,o],segments:r})};var z0=O0;const{TAU:qn}=I,b=T,Cn=N,Bn=B,{sin:On,cos:zn}=Q,{isGTE:D0,isNumberArray:Dn}=Bt,R0=t=>{const e={center:[0,0,0],radius:[1,1,1],segments:32,axes:[[1,0,0],[0,-1,0],[0,0,1]]},{center:n,radius:s,segments:o,axes:r}=Object.assign({},e,t);if(!Dn(n,3))throw new Error("center must be an array of X, Y and Z values");if(!Dn(s,3))throw new Error("radius must be an array of X, Y and Z values");if(!s.every(d=>d>=0))throw new Error("radius values must be positive");if(!D0(o,4))throw new Error("segments must be four or more");if(s[0]===0||s[1]===0||s[2]===0)return Cn.create();const c=b.scale(b.create(),b.normalize(b.create(),r[0]),s[0]),i=b.scale(b.create(),b.normalize(b.create(),r[1]),s[1]),l=b.scale(b.create(),b.normalize(b.create(),r[2]),s[2]),a=Math.round(o/4);let f;const h=[],p=b.create(),u=b.create();for(let d=0;d<=o;d++){const g=qn*d/o,y=b.add(b.create(),b.scale(p,c,zn(g)),b.scale(u,i,On(g)));if(d>0){let M,_;for(let P=0;P<=a;P++){const w=qn/4*P/a,$=zn(w),v=On(w);if(P>0){let m=[],x;x=b.subtract(b.create(),b.scale(p,f,M),b.scale(u,l,_)),m.push(b.add(x,x,n)),x=b.subtract(b.create(),b.scale(p,y,M),b.scale(u,l,_)),m.push(b.add(x,x,n)),P<a&&(x=b.subtract(b.create(),b.scale(p,y,$),b.scale(u,l,v)),m.push(b.add(x,x,n))),x=b.subtract(b.create(),b.scale(p,f,$),b.scale(u,l,v)),m.push(b.add(x,x,n)),h.push(Bn.create(m)),m=[],x=b.add(b.create(),b.scale(p,f,M),b.scale(u,l,_)),m.push(b.add(b.create(),n,x)),x=b.add(x,b.scale(p,y,M),b.scale(u,l,_)),m.push(b.add(b.create(),n,x)),P<a&&(x=b.add(x,b.scale(p,y,$),b.scale(u,l,v)),m.push(b.add(b.create(),n,x))),x=b.add(x,b.scale(p,f,$),b.scale(u,l,v)),m.push(b.add(b.create(),n,x)),m.reverse(),h.push(Bn.create(m))}M=$,_=v}}f=y}return Cn.create(h)};var L0=R0;const I0=L0,{isGTE:G0}=Bt,Z0=t=>{const e={center:[0,0,0],radius:1,segments:32,axes:[[1,0,0],[0,-1,0],[0,0,1]]};let{center:n,radius:s,segments:o,axes:r}=Object.assign({},e,t);if(!G0(s,0))throw new Error("radius must be positive");return s=[s,s,s],I0({center:n,radius:s,segments:o,axes:r})};var H0=Z0;const Po=t=>t.reduce((e,n)=>Array.isArray(n)?e.concat(Po(n)):e.concat(n),[]);var G=Po;const Rn=gt,dt=T,U0=t=>{const e=t.edges;if(e.length<3)throw new Error("slices must have 3 or more edges to calculate a plane");const n=e.reduce((c,i)=>dt.add(dt.create(),c,i[0]),dt.create());dt.scale(n,n,1/e.length);let s,o=0;e.forEach(c=>{if(!dt.equals(c[0],c[1])){const i=dt.squaredDistance(n,c[0]);i>o&&(s=c,o=i)}});const r=e.find(c=>dt.equals(c[1],s[0]));return Rn.fromPoints(Rn.create(),r[0],s[0],s[1])};var xo=U0;const X0=t=>(t||(t=[]),{edges:t});var vt=X0;const Y0=vt,Ln=T,W0=(...t)=>{let e,n;return t.length===1?(e=Y0(),n=t[0]):(e=t[0],n=t[1]),e.edges=n.edges.map(s=>[Ln.clone(s[0]),Ln.clone(s[1])]),e};var K0=W0;const Q0=T,J0=(t,e)=>{const n=t.edges,s=e.edges;return n.length!==s.length?!1:n.reduce((r,c,i)=>{const l=s[i],a=Q0.squaredDistance(c[0],l[0]);return r&&a<Number.EPSILON},!0)};var j0=J0;const It=T,tp=vt,ep=t=>{if(!Array.isArray(t))throw new Error("the given points must be an array");if(t.length<3)throw new Error("the given points must contain THREE or more points");const e=[];let n=t[t.length-1];return t.forEach(s=>{s.length===2&&e.push([It.fromVec2(It.create(),n),It.fromVec2(It.create(),s)]),s.length===3&&e.push([n,s]),n=s}),tp(e)};var np=ep;const Gt=T,sp=vt,op=t=>{if(!Array.isArray(t))throw new Error("the given sides must be an array");const e=[];return t.forEach(n=>{e.push([Gt.fromVec2(Gt.create(),n[0]),Gt.fromVec2(Gt.create(),n[1])])}),sp(e)};var rp=op;const cp=t=>!!(t&&typeof t=="object"&&"edges"in t&&Array.isArray(t.edges));var ip=cp;const ap=vt,lp=(...t)=>{let e,n;return t.length===1?(e=ap(),n=t[0]):(e=t[0],n=t[1]),e.edges=n.edges.map(s=>[s[1],s[0]]),e};var fp=lp;const hp=t=>t.edges;var pp=hp;const dp=(t,e)=>{let n,s,o,r,c,i=1;do{s=t,t=null;let l=null;for(c=0;s;){c++,o=s;let a=0;for(n=0;n<i&&(a++,o=o.nextZ,!!o);n++);let f=i;for(;a>0||f>0&&o;)a!==0&&(f===0||!o||e(s)<=e(o))?(r=s,s=s.nextZ,a--):(r=o,o=o.nextZ,f--),l?l.nextZ=r:t=r,r.prevZ=l,l=r;s=o}l.nextZ=null,i*=2}while(c>1);return t};var up=dp;const gp=up;let Eo=class{constructor(e,n,s){this.i=e,this.x=n,this.y=s,this.prev=null,this.next=null,this.z=null,this.prevZ=null,this.nextZ=null,this.steiner=!1}};const vp=(t,e,n,s)=>{const o=new Eo(t,e,n);return s?(o.next=s.next,o.prev=s,s.next.prev=o,s.next=o):(o.prev=o,o.next=o),o},$p=t=>{t.next.prev=t.prev,t.prev.next=t.next,t.prevZ&&(t.prevZ.nextZ=t.nextZ),t.nextZ&&(t.nextZ.prevZ=t.prevZ)};var _o={Node:Eo,insertNode:vp,removeNode:$p,sortLinked:gp};const mp=(t,e,n,s,o,r,c,i)=>(o-c)*(e-i)-(t-c)*(r-i)>=0&&(t-c)*(s-i)-(n-c)*(e-i)>=0&&(n-c)*(r-i)-(o-c)*(s-i)>=0,yp=(t,e,n)=>(e.y-t.y)*(n.x-e.x)-(e.x-t.x)*(n.y-e.y);var Ze={area:yp,pointInTriangle:mp};const{Node:In,insertNode:Gn,removeNode:Jt}=_o,{area:Y}=Ze,wp=(t,e,n,s,o)=>{let r;if(o===Sp(t,e,n,s)>0)for(let c=e;c<n;c+=s)r=Gn(c,t[c],t[c+1],r);else for(let c=n-s;c>=e;c-=s)r=Gn(c,t[c],t[c+1],r);return r&&ae(r,r.next)&&(Jt(r),r=r.next),r},Ao=(t,e)=>{if(!t)return t;e||(e=t);let n=t,s;do if(s=!1,!n.steiner&&(ae(n,n.next)||Y(n.prev,n,n.next)===0)){if(Jt(n),n=e=n.prev,n===n.next)break;s=!0}else n=n.next;while(s||n!==e);return e},Pp=(t,e,n)=>{let s=t;do{const o=s.prev,r=s.next.next;!ae(o,r)&&So(o,s,s.next,r)&&Nt(o,r)&&Nt(r,o)&&(e.push(o.i/n),e.push(s.i/n),e.push(r.i/n),Jt(s),Jt(s.next),s=t=r),s=s.next}while(s!==t);return Ao(s)},xp=(t,e)=>{let n=t;do{if(n.i!==t.i&&n.next.i!==t.i&&n.i!==e.i&&n.next.i!==e.i&&So(n,n.next,t,e))return!0;n=n.next}while(n!==t);return!1},Nt=(t,e)=>Y(t.prev,t,t.next)<0?Y(t,e,t.next)>=0&&Y(t,t.prev,e)>=0:Y(t,e,t.prev)<0||Y(t,t.next,e)<0,Ep=(t,e)=>{let n=t,s=!1;const o=(t.x+e.x)/2,r=(t.y+e.y)/2;do n.y>r!=n.next.y>r&&n.next.y!==n.y&&o<(n.next.x-n.x)*(r-n.y)/(n.next.y-n.y)+n.x&&(s=!s),n=n.next;while(n!==t);return s},_p=(t,e)=>{const n=new In(t.i,t.x,t.y),s=new In(e.i,e.x,e.y),o=t.next,r=e.prev;return t.next=e,e.prev=t,n.next=o,o.prev=n,s.next=n,n.prev=s,r.next=s,s.prev=r,s},Ap=(t,e)=>t.next.i!==e.i&&t.prev.i!==e.i&&!xp(t,e)&&(Nt(t,e)&&Nt(e,t)&&Ep(t,e)&&(Y(t.prev,t,e.prev)||Y(t,e.prev,e))||ae(t,e)&&Y(t.prev,t,t.next)>0&&Y(e.prev,e,e.next)>0),So=(t,e,n,s)=>{const o=Math.sign(Y(t,e,n)),r=Math.sign(Y(t,e,s)),c=Math.sign(Y(n,s,t)),i=Math.sign(Y(n,s,e));return!!(o!==r&&c!==i||o===0&&Zt(t,n,e)||r===0&&Zt(t,s,e)||c===0&&Zt(n,t,s)||i===0&&Zt(n,e,s))},Zt=(t,e,n)=>e.x<=Math.max(t.x,n.x)&&e.x>=Math.min(t.x,n.x)&&e.y<=Math.max(t.y,n.y)&&e.y>=Math.min(t.y,n.y),Sp=(t,e,n,s)=>{let o=0;for(let r=e,c=n-s;r<n;r+=s)o+=(t[c]-t[r])*(t[r+1]+t[c+1]),c=r;return o},ae=(t,e)=>t.x===e.x&&t.y===e.y;var bo={cureLocalIntersections:Pp,filterPoints:Ao,isValidDiagonal:Ap,linkedPolygon:wp,locallyInside:Nt,splitPolygon:_p};const{filterPoints:Ne,linkedPolygon:bp,locallyInside:Mp,splitPolygon:Tp}=bo,{area:Zn,pointInTriangle:Fp}=Ze,Vp=(t,e,n,s)=>{const o=[];for(let r=0,c=e.length;r<c;r++){const i=e[r]*s,l=r<c-1?e[r+1]*s:t.length,a=bp(t,i,l,s,!1);a===a.next&&(a.steiner=!0),o.push(Cp(a))}o.sort((r,c)=>r.x-c.x);for(let r=0;r<o.length;r++)n=kp(o[r],n),n=Ne(n,n.next);return n},kp=(t,e)=>{const n=Np(t,e);if(!n)return e;const s=Tp(n,t),o=Ne(n,n.next);return Ne(s,s.next),e===n?o:e},Np=(t,e)=>{let n=e;const s=t.x,o=t.y;let r=-1/0,c;do{if(o<=n.y&&o>=n.next.y&&n.next.y!==n.y){const h=n.x+(o-n.y)*(n.next.x-n.x)/(n.next.y-n.y);if(h<=s&&h>r){if(r=h,h===s){if(o===n.y)return n;if(o===n.next.y)return n.next}c=n.x<n.next.x?n:n.next}}n=n.next}while(n!==e);if(!c)return null;if(s===r)return c;const i=c,l=c.x,a=c.y;let f=1/0;n=c;do{if(s>=n.x&&n.x>=l&&s!==n.x&&Fp(o<a?s:r,o,l,a,o<a?r:s,o,n.x,n.y)){const h=Math.abs(o-n.y)/(s-n.x);Mp(n,t)&&(h<f||h===f&&(n.x>c.x||n.x===c.x&&qp(c,n)))&&(c=n,f=h)}n=n.next}while(n!==i);return c},qp=(t,e)=>Zn(t.prev,t,e.prev)<0&&Zn(e.next,t,t.next)<0,Cp=t=>{let e=t,n=t;do(e.x<n.x||e.x===n.x&&e.y<n.y)&&(n=e),e=e.next;while(e!==t);return n};var Bp=Vp;const Op=Bp,{removeNode:zp,sortLinked:Dp}=_o,{cureLocalIntersections:Rp,filterPoints:jt,isValidDiagonal:Lp,linkedPolygon:Ip,splitPolygon:Gp}=bo,{area:ut,pointInTriangle:kt}=Ze,Zp=(t,e,n=2)=>{const s=e&&e.length,o=s?e[0]*n:t.length;let r=Ip(t,0,o,n,!0);const c=[];if(!r||r.next===r.prev)return c;let i,l,a,f,h;if(s&&(r=Op(t,e,r,n)),t.length>80*n){i=a=t[0],l=f=t[1];for(let p=n;p<o;p+=n){const u=t[p],d=t[p+1];u<i&&(i=u),d<l&&(l=d),u>a&&(a=u),d>f&&(f=d)}h=Math.max(a-i,f-l),h=h!==0?1/h:0}return qt(r,c,n,i,l,h),c},qt=(t,e,n,s,o,r,c)=>{if(!t)return;!c&&r&&Yp(t,s,o,r);let i=t,l,a;for(;t.prev!==t.next;){if(l=t.prev,a=t.next,r?Up(t,s,o,r):Hp(t)){e.push(l.i/n),e.push(t.i/n),e.push(a.i/n),zp(t),t=a.next,i=a.next;continue}if(t=a,t===i){c?c===1?(t=Rp(jt(t),e,n),qt(t,e,n,s,o,r,2)):c===2&&Xp(t,e,n,s,o,r):qt(jt(t),e,n,s,o,r,1);break}}},Hp=t=>{const e=t.prev,n=t,s=t.next;if(ut(e,n,s)>=0)return!1;let o=t.next.next;for(;o!==t.prev;){if(kt(e.x,e.y,n.x,n.y,s.x,s.y,o.x,o.y)&&ut(o.prev,o,o.next)>=0)return!1;o=o.next}return!0},Up=(t,e,n,s)=>{const o=t.prev,r=t,c=t.next;if(ut(o,r,c)>=0)return!1;const i=o.x<r.x?o.x<c.x?o.x:c.x:r.x<c.x?r.x:c.x,l=o.y<r.y?o.y<c.y?o.y:c.y:r.y<c.y?r.y:c.y,a=o.x>r.x?o.x>c.x?o.x:c.x:r.x>c.x?r.x:c.x,f=o.y>r.y?o.y>c.y?o.y:c.y:r.y>c.y?r.y:c.y,h=qe(i,l,e,n,s),p=qe(a,f,e,n,s);let u=t.prevZ,d=t.nextZ;for(;u&&u.z>=h&&d&&d.z<=p;){if(u!==t.prev&&u!==t.next&&kt(o.x,o.y,r.x,r.y,c.x,c.y,u.x,u.y)&&ut(u.prev,u,u.next)>=0||(u=u.prevZ,d!==t.prev&&d!==t.next&&kt(o.x,o.y,r.x,r.y,c.x,c.y,d.x,d.y)&&ut(d.prev,d,d.next)>=0))return!1;d=d.nextZ}for(;u&&u.z>=h;){if(u!==t.prev&&u!==t.next&&kt(o.x,o.y,r.x,r.y,c.x,c.y,u.x,u.y)&&ut(u.prev,u,u.next)>=0)return!1;u=u.prevZ}for(;d&&d.z<=p;){if(d!==t.prev&&d!==t.next&&kt(o.x,o.y,r.x,r.y,c.x,c.y,d.x,d.y)&&ut(d.prev,d,d.next)>=0)return!1;d=d.nextZ}return!0},Xp=(t,e,n,s,o,r)=>{let c=t;do{let i=c.next.next;for(;i!==c.prev;){if(c.i!==i.i&&Lp(c,i)){let l=Gp(c,i);c=jt(c,c.next),l=jt(l,l.next),qt(c,e,n,s,o,r),qt(l,e,n,s,o,r);return}i=i.next}c=c.next}while(c!==t)},Yp=(t,e,n,s)=>{let o=t;do o.z===null&&(o.z=qe(o.x,o.y,e,n,s)),o.prevZ=o.prev,o.nextZ=o.next,o=o.next;while(o!==t);o.prevZ.nextZ=null,o.prevZ=null,Dp(o,r=>r.z)},qe=(t,e,n,s,o)=>(t=32767*(t-n)*o,e=32767*(e-s)*o,t=(t|t<<8)&16711935,t=(t|t<<4)&252645135,t=(t|t<<2)&858993459,t=(t|t<<1)&1431655765,e=(e|e<<8)&16711935,e=(e|e<<4)&252645135,e=(e|e<<2)&858993459,e=(e|e<<1)&1431655765,t|e<<1);var Wp=Zp;const Kp=t=>{let e=0;for(let n=0;n<t.length;n++){const s=(n+1)%t.length;e+=t[n][0]*t[s][1],e-=t[s][0]*t[n][1]}return e/2};var Mo=Kp;const Qp=(t,e,n)=>{let s=n-t[1],o=e[1]-t[1];o<0&&(s=-s,o=-o);let r;return s<=0?r=0:s>=o?r=1:o<1e-10?r=.5:r=s/o,t[0]+r*(e[0]-t[0])};var Jp=Qp;const jp=(t,e,n,s,o,r)=>{const i=1/(t*s-e*n);let l=o*s-e*r,a=-o*n+t*r;return l*=i,a*=i,[l,a]};var td=jp,To={area:Mo,solve2Linear:td};const ed=Mo,nd=t=>ed(t.vertices);var sd=nd;const od=t=>((t===void 0||t.length<3)&&(t=[]),{vertices:t});var rd=od;const cd=rd,id=t=>{const e=t.vertices.slice().reverse();return cd(e)};var ad=id;const ld=sd,fd=ad,hd=(t,e)=>{if(t.length===0)return 0;const n=e.vertices;return n.length<3?0:(ld(e)<0&&(e=fd(e)),t.reduce((o,r)=>o+pd(r,n),0)===t.length?1:0)},pd=(t,e)=>{const n=e.length,s=t[0],o=t[1];let r=e[n-1],c=e[0],i=r[1]>o,l=0,a=0;for(let f=n+1;--f;){const h=c[1]>o;if(i!==h){const p=r[0]>s,u=c[0]>s;(p&&u||c[0]-(c[1]-o)*(r[0]-c[0])/(r[1]-c[1])>=s)&&(l=!l)}i=h,r=c,c=e[++a]}return l};var dd=hd,ud={arePointsInside:dd};const{area:gd}=To,{toOutlines:vd}=R,{arePointsInside:$d}=ud,md=t=>{const e=vd(t),n=[],s=[];e.forEach((c,i)=>{const l=gd(c);l<0?s.push(i):l>0&&n.push(i)});const o=[],r=[];return n.forEach((c,i)=>{const l=e[c];o[i]=[],s.forEach((a,f)=>{const h=e[a];$d([h[0]],{vertices:l})&&(o[i].push(a),r[f]||(r[f]=[]),r[f].push(i))})}),s.forEach((c,i)=>{if(r[i]&&r[i].length>1){const l=yd(r[i],a=>o[a].length);r[i].forEach((a,f)=>{f!==l&&(o[a]=o[a].filter(h=>h!==c))})}}),o.map((c,i)=>({solid:e[n[i]],holes:c.map(l=>e[l])}))},yd=(t,e)=>{let n,s;return t.forEach((o,r)=>{const c=e(o);(s===void 0||c<s)&&(n=r,s=c)}),n};var wd=md;const Pd=R,Hn=gt,xd=k,H=T,Ed=xo,_d=wd;let Ad=class{constructor(e){this.plane=Ed(e);const n=H.orthogonal(H.create(),this.plane),s=H.cross(H.create(),this.plane,n);this.v=H.normalize(s,s),this.u=H.cross(H.create(),this.v,this.plane),this.basisMap=new Map;const o=e.edges.map(c=>c.map(i=>this.to2D(i))),r=Pd.create(o);this.roots=_d(r)}to2D(e){const n=xd.fromValues(H.dot(e,this.u),H.dot(e,this.v));return this.basisMap.set(n,e),n}to3D(e){const n=this.basisMap.get(e);if(n)return n;{console.log("Warning: point not in original slice");const s=H.scale(H.create(),this.u,e[0]),o=H.scale(H.create(),this.v,e[1]),r=H.scale(H.create(),Hn,Hn[3]),c=H.add(s,s,r);return H.add(o,o,c)}}};var Sd=Ad;const bd=B,Md=Wp,Td=Sd,Fd=t=>{const e=new Td(t),n=[];return e.roots.forEach(({solid:s,holes:o})=>{let r=s.length;const c=[];o.forEach((h,p)=>{c.push(r),r+=h.length});const i=[s,...o].flat(),l=i.flat(),a=h=>e.to3D(i[h]),f=Md(l,c);for(let h=0;h<f.length;h+=3){const p=f.slice(h,h+3).map(a);n.push(bd.fromPointsAndPlane(p,e.plane))}}),n};var Vd=Fd;const Un=T,kd=t=>t.reduce((e,n)=>e+=`[${Un.toString(n[0])}, ${Un.toString(n[1])}], `,""),Nd=t=>`[${kd(t.edges)}]`;var qd=Nd;const Ht=T,Cd=vt,Bd=(t,e)=>{const n=e.edges.map(s=>[Ht.transform(Ht.create(),s[0],t),Ht.transform(Ht.create(),s[1],t)]);return Cd(n)};var Od=Bd,He={calculatePlane:xo,clone:K0,create:vt,equals:j0,fromPoints:np,fromSides:rp,isA:ip,reverse:fp,toEdges:pp,toPolygons:Vd,toString:qd,transform:Od};const Xn=T,zd=vt,Dd=t=>{if(!t.edges)return t;let e=t.edges;const n=new Map,s=new Map;e=e.filter(c=>!Xn.equals(c[0],c[1])),e.forEach(c=>{const i=c[0].toString(),l=c[1].toString();n.set(i,c[0]),n.set(l,c[1]),s.set(i,(s.get(i)||0)+1),s.set(l,(s.get(l)||0)-1)});const o=[],r=[];return s.forEach((c,i)=>{c<0&&o.push(i),c>0&&r.push(i)}),o.forEach(c=>{const i=n.get(c);let l=1/0,a;r.forEach(f=>{const h=n.get(f),p=Xn.distance(i,h);p<l&&(l=p,a=h)}),console.warn(`slice.repair: repairing vertex gap ${i} to ${a} distance ${l}`),e=e.map(f=>f[0].toString()===c?[a,f[1]]:f[1].toString()===c?[f[0],a]:f)}),zd(e)};var Rd=Dd;const{EPS:Yn}=I,mt=T,Ut=B,Wn=He,Ce=(t,e)=>t===e?t:t<e?Ce(e,t):e===1?1:e===0?t:Ce(e,t%e),Ld=(t,e)=>t*e/Ce(t,e),Kn=(t,e)=>{const n=t/e.length;if(n===1)return e;const s=mt.fromValues(n,n,n),o=[];return e.forEach(r=>{const c=mt.subtract(mt.create(),r[1],r[0]);mt.divide(c,c,s);let i=r[0];for(let l=1;l<=n;++l){const a=mt.add(mt.create(),i,c);o.push([i,a]),i=a}}),o},Qn=Yn*Yn/2*Math.sin(Math.PI/3),Id=(t,e)=>{let n=Wn.toEdges(t),s=Wn.toEdges(e);if(n.length!==s.length){const r=Ld(n.length,s.length);r!==n.length&&(n=Kn(r,n)),r!==s.length&&(s=Kn(r,s))}const o=[];return n.forEach((r,c)=>{const i=s[c],l=Ut.create([r[0],r[1],i[1]]),a=Ut.measureArea(l);Number.isFinite(a)&&a>Qn&&o.push(l);const f=Ut.create([r[0],i[1],i[0]]),h=Ut.measureArea(f);Number.isFinite(h)&&h>Qn&&o.push(f)}),o};var Gd=Id;const Jn=D,jn=R,Zd=N,Be=B,ht=He,Hd=Rd,ts=Gd,Ud=(t,e,n)=>{let s=null;return jn.isA(n)&&(s=ht.fromSides(jn.toSides(n))),Be.isA(n)&&(s=ht.fromPoints(Be.toPoints(n))),t===0||t===1?ht.transform(Jn.fromTranslation(Jn.create(),[0,0,t]),s):null},Xd=(t,e)=>{const n={numberOfSlices:2,capStart:!0,capEnd:!0,close:!1,repair:!0,callback:Ud},{numberOfSlices:s,capStart:o,capEnd:r,close:c,repair:i,callback:l}=Object.assign({},n,t);if(s<2)throw new Error("numberOfSlices must be 2 or more");i&&(e=Hd(e));const a=s-1;let f=null,h=null,p=null,u=[];for(let d=0;d<s;d++){const g=l(d/a,d,e);if(g){if(!ht.isA(g))throw new Error("the callback function must return slice objects");if(ht.toEdges(g).length===0)throw new Error("the callback function must return slices with one or more edges");p&&(u=u.concat(ts(p,g))),d===0&&(f=g),d===s-1&&(h=g),p=g}}if(r){const d=ht.toPolygons(h);u=u.concat(d)}if(o){const d=ht.toPolygons(f).map(Be.invert);u=u.concat(d)}return!o&&!r&&c&&!ht.equals(h,f)&&(u=u.concat(ts(h,f))),Zd.create(u)};var Yd=Xd;const Wd=G,es=D,ns=R,ss=N,os=tt,Kd=(t,...e)=>{if(!Array.isArray(t))throw new Error("angles must be an array");if(e=Wd(e),e.length===0)throw new Error("wrong number of arguments");for(t=t.slice();t.length<3;)t.push(0);const n=t[2],s=t[1],o=t[0],r=es.fromTaitBryanRotation(es.create(),n,s,o),c=e.map(i=>os.isA(i)?os.transform(r,i):ns.isA(i)?ns.transform(r,i):ss.isA(i)?ss.transform(r,i):i);return c.length===1?c[0]:c};var Qd={rotate:Kd};const Jd=G,rs=D,cs=R,is=N,as=tt,jd=(t,...e)=>{if(!Array.isArray(t))throw new Error("offset must be an array");if(e=Jd(e),e.length===0)throw new Error("wrong number of arguments");for(t=t.slice();t.length<3;)t.push(0);const n=rs.fromTranslation(rs.create(),t),s=e.map(o=>as.isA(o)?as.transform(n,o):cs.isA(o)?cs.transform(n,o):is.isA(o)?is.transform(n,o):o);return s.length===1?s[0]:s};var tu={translate:jd},Xt={cuboid:S0,cylinder:z0,sphere:H0};const eu=R,nu=N,su=tt,ou=t=>{let e;for(const n of t){let s=0;if(eu.isA(n)&&(s=1),nu.isA(n)&&(s=2),su.isA(n)&&(s=3),e&&s!==e)return!1;e=s}return!0};var le=ou,ru={geom2:R,geom3:N,path2:tt};const{EPS:cu}=I,iu=(t,e)=>{let n=0;for(let s=0;s<e;s++)n+=t[1][s]-t[0][s];return cu*n/e};var au=iu;const lu=G,st=k,Mt=T,Fo=R,Vo=N,ko=tt,ls=B,Et=new WeakMap,fu=t=>{let e=Et.get(t);if(e)return e;const n=ko.toPoints(t);let s;n.length===0?s=st.create():s=st.clone(n[0]);let o=st.clone(s);return n.forEach(r=>{st.min(s,s,r),st.max(o,o,r)}),s=[s[0],s[1],0],o=[o[0],o[1],0],e=[s,o],Et.set(t,e),e},hu=t=>{let e=Et.get(t);if(e)return e;const n=Fo.toPoints(t);let s;n.length===0?s=st.create():s=st.clone(n[0]);let o=st.clone(s);return n.forEach(r=>{st.min(s,s,r),st.max(o,o,r)}),s=[s[0],s[1],0],o=[o[0],o[1],0],e=[s,o],Et.set(t,e),e},pu=t=>{let e=Et.get(t);if(e)return e;const n=Vo.toPolygons(t);let s=Mt.create();if(n.length>0){const r=ls.toPoints(n[0]);Mt.copy(s,r[0])}let o=Mt.clone(s);return n.forEach(r=>{ls.toPoints(r).forEach(c=>{Mt.min(s,s,c),Mt.max(o,o,c)})}),s=[s[0],s[1],s[2]],o=[o[0],o[1],o[2]],e=[s,o],Et.set(t,e),e},du=(...t)=>{if(t=lu(t),t.length===0)throw new Error("wrong number of arguments");const e=t.map(n=>ko.isA(n)?fu(n):Fo.isA(n)?hu(n):Vo.isA(n)?pu(n):[[0,0,0],[0,0,0]]);return e.length===1?e[0]:e};var No=du;const uu=G,{geom2:gu,geom3:vu,path2:$u}=ru,Ue=au,Xe=No,mu=t=>Ue(Xe(t),2),yu=t=>Ue(Xe(t),2),wu=t=>Ue(Xe(t),3),Pu=(...t)=>{if(t=uu(t),t.length===0)throw new Error("wrong number of arguments");const e=t.map(n=>$u.isA(n)?mu(n):gu.isA(n)?yu(n):vu.isA(n)?wu(n):0);return e.length===1?e[0]:e};var Ye=Pu;const fs=k,xu=R,Eu=(t,e)=>{if(e.vertices.length<4)return null;const n=[],s=e.vertices.filter((c,i)=>c[2]>0?(n.push(i),!0):!1);if(s.length!==2)throw new Error("Assertion failed: fromFakePolygon: not enough points found");const o=s.map(c=>{const i=Math.round(c[0]/t)*t+0,l=Math.round(c[1]/t)*t+0;return fs.fromValues(i,l)});if(fs.equals(o[0],o[1]))return null;const r=n[1]-n[0];if(r===1||r===3)r===1&&o.reverse();else throw new Error("Assertion failed: fromFakePolygon: unknown index ordering");return o},_u=(t,e)=>{const n=e.map(s=>Eu(t,s)).filter(s=>s!==null);return xu.create(n)};var We=_u;const lt=T,Au=R,Su=N,bu=B,Mu=(t,e,n)=>{const s=[lt.fromVec2(lt.create(),n[0],t),lt.fromVec2(lt.create(),n[1],t),lt.fromVec2(lt.create(),n[1],e),lt.fromVec2(lt.create(),n[0],e)];return bu.create(s)},Tu=(t,e)=>{const s=Au.toSides(e).map(r=>Mu(t.z0,t.z1,r));return Su.create(s)};var Ke=Tu;const Fu=()=>[0,1,0];var Qe=Fu;const Vu=Qe,ku=t=>{const e=Vu();return e[0]=t[0],e[1]=t[1],e[2]=t[2],e};var Nu=ku;const Ae=k,qu=t=>{const e=Ae.normal(Ae.create(),t);return Ae.negate(e,e),e};var Je=qu;const hs=k,Cu=t=>hs.scale(hs.create(),t,t[2]);var fe=Cu;const Tt=k,Bu=Je,Ou=fe,zu=(t,e)=>{const n=Ou(t),s=Bu(t),o=Tt.subtract(Tt.create(),e,n),r=Tt.dot(o,s);return Tt.scale(o,s,r),Tt.add(o,o,n),o};var Du=zu;const Ru=(t,e)=>(t[0]=e[0],t[1]=e[1],t[2]=e[2],t);var qo=Ru;const Lu=k,Iu=(t,e)=>{let n=Lu.dot(e,t);return n=Math.abs(n-t[2]),n};var Gu=Iu;const Zu=(t,e)=>t[0]===e[0]&&t[1]===e[1]&&t[2]===e[2];var Hu=Zu;const Ft=k,Uu=(t,e,n)=>{const s=Ft.subtract(Ft.create(),n,e);Ft.normal(s,s),Ft.normalize(s,s);const o=Ft.dot(e,s);return t[0]=s[0],t[1]=s[1],t[2]=o,t};var Co=Uu;const Xu=Qe,Yu=(t,e,n)=>{const s=Xu();return s[0]=t,s[1]=e,s[2]=n,s};var Bo=Yu;const Wu=k,{solve2Linear:Ku}=To,Qu=(t,e)=>{const n=Ku(t[0],t[1],e[0],e[1],t[2],e[2]);return Wu.clone(n)};var Ju=Qu;const ps=k,ju=qo,tg=Bo,eg=(t,e)=>{const n=ps.negate(ps.create(),e),s=-e[2];return ju(t,tg(n[0],n[1],s))};var ng=eg;const sg=t=>`line2: (${t[0].toFixed(7)}, ${t[1].toFixed(7)}, ${t[2].toFixed(7)})`;var og=sg;const ds=k,rg=Co,cg=fe,ig=Je,ag=(t,e,n)=>{const s=cg(e),o=ig(e);return ds.transform(s,s,n),ds.transform(o,o,n),rg(t,s,o)};var lg=ag;const fg=fe,hg=(t,e)=>{let n=(t[2]-t[1]*e)/t[0];return Number.isNaN(n)&&(n=fg(t)[0]),n};var pg=hg,dg={clone:Nu,closestPoint:Du,copy:qo,create:Qe,direction:Je,distanceToPoint:Gu,equals:Hu,fromPoints:Co,fromValues:Bo,intersectPointOfLines:Ju,origin:fe,reverse:ng,toString:og,transform:lg,xAtY:pg};const us=D,ug=k,z=T,Oo=function(t,e){arguments.length<2&&(e=z.orthogonal(z.create(),t)),this.v=z.normalize(z.create(),z.cross(z.create(),t,e)),this.u=z.cross(z.create(),this.v,t),this.plane=t,this.planeorigin=z.scale(z.create(),t,t[3])};Oo.prototype={getProjectionMatrix:function(){return us.fromValues(this.u[0],this.v[0],this.plane[0],0,this.u[1],this.v[1],this.plane[1],0,this.u[2],this.v[2],this.plane[2],0,0,0,-this.plane[3],1)},getInverseProjectionMatrix:function(){const t=z.scale(z.create(),this.plane,this.plane[3]);return us.fromValues(this.u[0],this.u[1],this.u[2],0,this.v[0],this.v[1],this.v[2],0,this.plane[0],this.plane[1],this.plane[2],0,t[0],t[1],t[2],1)},to2D:function(t){return ug.fromValues(z.dot(t,this.u),z.dot(t,this.v))},to3D:function(t){const e=z.scale(z.create(),this.u,t[0]),n=z.scale(z.create(),this.v,t[1]),s=z.add(e,e,this.planeorigin);return z.add(n,n,s)}};var gg=Oo;const vg=(t,e)=>t-e;var $g=vg;const mg=(t,e,n)=>{let s=0,o=t.length;for(;o>s;){const r=Math.floor((s+o)/2),c=t[r];n(e,c)>0?s=r+1:o=r}t.splice(s,0,e)};var yg=mg,wg={fnNumberSort:$g,insertSorted:yg};const{EPS:ct}=I,ft=dg,j=k,Pg=gg,yt=Jp,{insertSorted:xg,fnNumberSort:Eg}=wg,gs=B,_g=t=>{if(t.length<2)return t;const e=[],n=t.length,s=gs.plane(t[0]),o=new Pg(s),r=[],c=[],i=new Map,l=new Map,a=new Map,f=10/ct;for(let d=0;d<n;d++){const g=t[d];let y=[],M=g.vertices.length,_=-1;if(M>0){let P,w;for(let $=0;$<M;$++){let v=o.to2D(g.vertices[$]);const m=Math.floor(v[1]*f);let x;a.has(m)?x=a.get(m):a.has(m+1)?x=a.get(m+1):a.has(m-1)?x=a.get(m-1):(x=v[1],a.set(m,v[1])),v=j.fromValues(v[0],x),y.push(v);const A=v[1];($===0||A<P)&&(P=A,_=$),($===0||A>w)&&(w=A);let E=l.get(A);E||(E={},l.set(A,E)),E[d]=!0}if(P>=w)y=[],M=0,_=-1;else{let $=i.get(P);$||($=[],i.set(P,$)),$.push(d)}}y.reverse(),_=M-_-1,r.push(y),c.push(_)}const h=[];l.forEach((d,g)=>h.push(g)),h.sort(Eg);let p=[],u=[];for(let d=0;d<h.length;d++){const g=[],y=h[d],M=l.get(y);for(let P=0;P<p.length;++P){const w=p[P],$=w.polygonindex;if(M[$]){const v=r[$],m=v.length;let x=w.leftvertexindex,A=w.rightvertexindex;for(;;){let S=x+1;if(S>=m&&(S=0),v[S][1]!==y)break;x=S}let E=A-1;if(E<0&&(E=m-1),v[E][1]===y&&(A=E),x!==w.leftvertexindex&&x===A)p.splice(P,1),--P;else{w.leftvertexindex=x,w.rightvertexindex=A,w.topleft=v[x],w.topright=v[A];let S=x+1;S>=m&&(S=0),w.bottomleft=v[S];let V=A-1;V<0&&(V=m-1),w.bottomright=v[V]}}}let _;if(d>=h.length-1)p=[],_=null;else{_=Number(h[d+1]);const P=.5*(y+_),w=i.get(y);for(const $ in w){const v=w[$],m=r[v],x=m.length,A=c[v];let E=A;for(;;){let C=E+1;if(C>=x&&(C=0),m[C][1]!==y||C===A)break;E=C}let S=A;for(;;){let C=S-1;if(C<0&&(C=x-1),m[C][1]!==y||C===E)break;S=C}let V=E+1;V>=x&&(V=0);let q=S-1;q<0&&(q=x-1);const F={polygonindex:v,leftvertexindex:E,rightvertexindex:S,topleft:m[E],topright:m[S],bottomleft:m[V],bottomright:m[q]};xg(p,F,(C,L)=>{const et=yt(C.topleft,C.bottomleft,P),J=yt(L.topleft,L.bottomleft,P);return et>J?1:et<J?-1:0})}}for(const P in p){const w=p[P];let $=yt(w.topleft,w.bottomleft,y);const v=j.fromValues($,y);$=yt(w.topright,w.bottomright,y);const m=j.fromValues($,y);$=yt(w.topleft,w.bottomleft,_);const x=j.fromValues($,_);$=yt(w.topright,w.bottomright,_);const A=j.fromValues($,_),E={topleft:v,topright:m,bottomleft:x,bottomright:A,leftline:ft.fromPoints(ft.create(),v,x),rightline:ft.fromPoints(ft.create(),A,m)};if(g.length>0){const S=g[g.length-1],V=j.distance(E.topleft,S.topright),q=j.distance(E.bottomleft,S.bottomright);V<ct&&q<ct&&(E.topleft=S.topleft,E.leftline=S.leftline,E.bottomleft=S.bottomleft,g.splice(g.length-1,1))}g.push(E)}if(d>0){const P=new Set,w=new Set;for(let $=0;$<g.length;$++){const v=g[$];for(let m=0;m<u.length;m++)if(!w.has(m)){const x=u[m];if(j.distance(x.bottomleft,v.topleft)<ct&&j.distance(x.bottomright,v.topright)<ct){w.add(m);const A=ft.direction(v.leftline),E=ft.direction(x.leftline),S=A[0]-E[0],V=ft.direction(v.rightline),q=ft.direction(x.rightline),F=V[0]-q[0],C=Math.abs(S)<ct,L=Math.abs(F)<ct,et=C||S>=0,J=L||F>=0;et&&J&&(v.outpolygon=x.outpolygon,v.leftlinecontinues=C,v.rightlinecontinues=L,P.add(m));break}}}for(let $=0;$<u.length;$++)if(!P.has($)){const v=u[$];v.outpolygon.rightpoints.push(v.bottomright),j.distance(v.bottomright,v.bottomleft)>ct&&v.outpolygon.leftpoints.push(v.bottomleft),v.outpolygon.leftpoints.reverse();const x=v.outpolygon.rightpoints.concat(v.outpolygon.leftpoints).map(E=>o.to3D(E)),A=gs.fromPointsAndPlane(x,s);A.vertices.length&&e.push(A)}}for(let P=0;P<g.length;P++){const w=g[P];w.outpolygon?(w.leftlinecontinues||w.outpolygon.leftpoints.push(w.topleft),w.rightlinecontinues||w.outpolygon.rightpoints.push(w.topright)):(w.outpolygon={leftpoints:[],rightpoints:[]},w.outpolygon.leftpoints.push(w.topleft),j.distance(w.topleft,w.topright)>ct&&w.outpolygon.rightpoints.push(w.topright))}u=g}return e};var Ag=_g;const vs=N,Sg=B,{NEPS:bg}=I,Mg=Ag,Tg=t=>{if(t.isRetesselated)return t;const e=vs.toPolygons(t).map((r,c)=>({vertices:r.vertices,plane:Sg.plane(r),index:c})),n=Fg(e),s=[];n.forEach(r=>{if(Array.isArray(r)){const c=Mg(r);s.push(...c)}else s.push(r)});const o=vs.create(s);return o.isRetesselated=!0,o},Fg=t=>{let e=[t];const n=[];for(let o=3;o>=0;o--){const r=[],c=o===3?15e-9:bg;e.forEach(i=>{i.sort(Vg(o,c));let l=0;for(let a=1;a<i.length;a++)i[a].plane[o]-i[l].plane[o]>c&&(a-l===1?n.push(i[l]):r.push(i.slice(l,a)),l=a);i.length-l===1?n.push(i[l]):r.push(i.slice(l))}),e=r}const s=[];return e.forEach(o=>{o[0]&&(s[o[0].index]=o)}),n.forEach(o=>{s[o.index]=o}),s},Vg=(t,e)=>(n,s)=>n.plane[t]-s.plane[t]>e?1:s.plane[t]-n.plane[t]>e?-1:0;var je=Tg;const{EPS:wt}=I,$s=No,kg=(t,e)=>{if(t.polygons.length===0||e.polygons.length===0)return!1;const n=$s(t),s=n[0],o=n[1],r=$s(e),c=r[0],i=r[1];return!(c[0]-o[0]>wt||s[0]-i[0]>wt||c[1]-o[1]>wt||s[1]-i[1]>wt||c[2]-o[2]>wt||s[2]-i[2]>wt)};var tn=kg;const ms=gt,Ng=B;let qg=class Oe{constructor(e){this.plane=null,this.front=null,this.back=null,this.polygontreenodes=[],this.parent=e}invert(){const e=[this];let n;for(let s=0;s<e.length;s++){n=e[s],n.plane&&(n.plane=ms.flip(ms.create(),n.plane)),n.front&&e.push(n.front),n.back&&e.push(n.back);const o=n.front;n.front=n.back,n.back=o}}clipPolygons(e,n){let s={node:this,polygontreenodes:e},o;const r=[];do{if(o=s.node,e=s.polygontreenodes,o.plane){const c=o.plane,i=[],l=[],a=n?i:l,f=e.length;for(let p=0;p<f;p++){const u=e[p];u.isRemoved()||u.splitByPlane(c,a,i,l,i)}o.front&&l.length>0&&r.push({node:o.front,polygontreenodes:l});const h=i.length;if(o.back&&h>0)r.push({node:o.back,polygontreenodes:i});else for(let p=0;p<h;p++)i[p].remove()}s=r.pop()}while(s!==void 0)}clipTo(e,n){let s=this;const o=[];do s.polygontreenodes.length>0&&e.rootnode.clipPolygons(s.polygontreenodes,n),s.front&&o.push(s.front),s.back&&o.push(s.back),s=o.pop();while(s!==void 0)}addPolygonTreeNodes(e){let n={node:this,polygontreenodes:e};const s=[];do{const o=n.node,r=n.polygontreenodes;if(r.length===0){n=s.pop();continue}if(!o.plane){let a=0;a=Math.floor(r.length/2);const f=r[a].getPolygon();o.plane=Ng.plane(f)}const c=[],i=[],l=r.length;for(let a=0;a<l;++a)r[a].splitByPlane(o.plane,o.polygontreenodes,i,c,i);c.length>0&&(o.front||(o.front=new Oe(o)),l===c.length&&i.length===0?o.front.polygontreenodes=c:s.push({node:o.front,polygontreenodes:c})),i.length>0&&(o.back||(o.back=new Oe(o)),l===i.length&&c.length===0?o.back.polygontreenodes=i:s.push({node:o.back,polygontreenodes:i})),n=s.pop()}while(n!==void 0)}};var Cg=qg;const Pt=T,Bg=(t,e,n)=>{const s=Pt.subtract(Pt.create(),n,e);let o=(t[3]-Pt.dot(t,e))/Pt.dot(t,s);return Number.isNaN(o)&&(o=0),o>1&&(o=1),o<0&&(o=0),Pt.scale(s,s,o),Pt.add(s,e,s),s};var Og=Bg;const{EPS:Yt}=I,zg=gt,Wt=T,Se=B,Dg=Og,Rg=(t,e)=>{const n={type:null,front:null,back:null},s=e.vertices,o=s.length,r=Se.plane(e);if(zg.equals(r,t))n.type=0;else{let c=!1,i=!1;const l=[],a=-Yt;for(let f=0;f<o;f++){const h=Wt.dot(t,s[f])-t[3],p=h<a;l.push(p),h>Yt&&(c=!0),h<a&&(i=!0)}if(!c&&!i){const f=Wt.dot(t,r);n.type=f>=0?0:1}else if(!i)n.type=2;else if(!c)n.type=3;else{n.type=4;const f=[],h=[];let p=l[0];for(let d=0;d<o;d++){const g=s[d];let y=d+1;y>=o&&(y=0);const M=l[y];if(p===M)p?h.push(g):f.push(g);else{const _=s[y],P=Dg(t,g,_);p?(h.push(g),h.push(P),f.push(P)):(f.push(g),f.push(P),h.push(P))}p=M}const u=Yt*Yt;if(h.length>=3){let d=h[h.length-1];for(let g=0;g<h.length;g++){const y=h[g];Wt.squaredDistance(y,d)<u&&(h.splice(g,1),g--),d=y}}if(f.length>=3){let d=f[f.length-1];for(let g=0;g<f.length;g++){const y=f[g];Wt.squaredDistance(y,d)<u&&(f.splice(g,1),g--),d=y}}f.length>=3&&(n.front=Se.fromPointsAndPlane(f,r)),h.length>=3&&(n.back=Se.fromPointsAndPlane(h,r))}}return n};var Lg=Rg;const{EPS:Ig}=I,Gg=T,ys=B,Zg=Lg;let Hg=class zo{constructor(e,n){this.parent=e,this.children=[],this.polygon=n,this.removed=!1}addPolygons(e){if(!this.isRootNode())throw new Error("Assertion failed");const n=this;e.forEach(s=>{n.addChild(s)})}remove(){if(!this.removed){this.removed=!0,this.polygon=null;const e=this.parent.children,n=e.indexOf(this);if(n<0)throw new Error("Assertion failed");e.splice(n,1),this.parent.recursivelyInvalidatePolygon()}}isRemoved(){return this.removed}isRootNode(){return!this.parent}invert(){if(!this.isRootNode())throw new Error("Assertion failed");this.invertSub()}getPolygon(){if(!this.polygon)throw new Error("Assertion failed");return this.polygon}getPolygons(e){let n=[this];const s=[n];let o,r,c,i;for(o=0;o<s.length;++o)for(n=s[o],r=0,c=n.length;r<c;r++)i=n[r],i.polygon?e.push(i.polygon):i.children.length>0&&s.push(i.children)}splitByPlane(e,n,s,o,r){if(this.children.length){const c=[this.children];let i,l,a,f,h;for(i=0;i<c.length;i++)for(h=c[i],l=0,a=h.length;l<a;l++)f=h[l],f.children.length>0?c.push(f.children):f._splitByPlane(e,n,s,o,r)}else this._splitByPlane(e,n,s,o,r)}_splitByPlane(e,n,s,o,r){const c=this.polygon;if(c){const i=ys.measureBoundingSphere(c),l=i[3]+Ig,a=i,f=Gg.dot(e,a)-e[3];if(f>l)o.push(this);else if(f<-l)r.push(this);else{const h=Zg(e,c);switch(h.type){case 0:n.push(this);break;case 1:s.push(this);break;case 2:o.push(this);break;case 3:r.push(this);break;case 4:if(h.front){const p=this.addChild(h.front);o.push(p)}if(h.back){const p=this.addChild(h.back);r.push(p)}break}}}}addChild(e){const n=new zo(this,e);return this.children.push(n),n}invertSub(){let e=[this];const n=[e];let s,o,r,c;for(s=0;s<n.length;s++)for(e=n[s],o=0,r=e.length;o<r;o++)c=e[o],c.polygon&&(c.polygon=ys.invert(c.polygon)),c.children.length>0&&n.push(c.children)}recursivelyInvalidatePolygon(){this.polygon=null,this.parent&&this.parent.recursivelyInvalidatePolygon()}clear(){let e=[this];const n=[e];for(let s=0;s<n.length;++s){e=n[s];const o=e.length;for(let r=0;r<o;r++){const c=e[r];c.polygon&&(c.polygon=null),c.parent&&(c.parent=null),c.children.length>0&&n.push(c.children),c.children=[]}}}toString(){let e="",n=[this];const s=[n];let o,r,c,i;for(o=0;o<s.length;++o){n=s[o];const l=" ".repeat(o);for(r=0,c=n.length;r<c;r++)i=n[r],e+=`${l}PolygonTreeNode (${i.isRootNode()}): ${i.children.length}`,i.polygon?e+=`
 ${l}polygon: ${i.polygon.vertices}
`:e+=`
`,i.children.length>0&&s.push(i.children)}return e}};var Ug=Hg;const Xg=Cg,Yg=Ug;let Wg=class{constructor(e){this.polygonTree=new Yg,this.rootnode=new Xg(null),e&&this.addPolygons(e)}invert(){this.polygonTree.invert(),this.rootnode.invert()}clipTo(e,n=!1){this.rootnode.clipTo(e,n)}allPolygons(){const e=[];return this.polygonTree.getPolygons(e),e}addPolygons(e){const n=new Array(e.length);for(let s=0;s<e.length;s++)n[s]=this.polygonTree.addChild(e[s]);this.rootnode.addPolygonTreeNodes(n)}clear(){this.polygonTree.clear()}toString(){return"Tree: "+this.polygonTree.toString("")}};var Kg=Wg,en={Tree:Kg};const Kt=N,Qg=tn,{Tree:ws}=en,Jg=(t,e)=>{if(!Qg(t,e))return Kt.create();const n=new ws(Kt.toPolygons(t)),s=new ws(Kt.toPolygons(e));n.invert(),s.clipTo(n),s.invert(),n.clipTo(s),s.clipTo(n),n.addPolygons(s.allPolygons()),n.invert();const o=n.allPolygons();return Kt.create(o)};var jg=Jg;const tv=G,ev=je,nv=jg,sv=(...t)=>{t=tv(t);let e=t.shift();return t.forEach(n=>{e=nv(e,n)}),e=ev(e),e};var Do=sv;const ov=G,rv=N,cv=Ye,iv=We,av=Ke,lv=Do,fv=(...t)=>{t=ov(t);const e=t.map(o=>av({z0:-1,z1:1},o)),n=lv(e),s=cv(n);return iv(s,rv.toPolygons(n))};var hv=fv;const pv=G,dv=le,uv=R,gv=N,vv=hv,$v=Do,mv=(...t)=>{if(t=pv(t),t.length===0)throw new Error("wrong number of arguments");if(!dv(t))throw new Error("only intersect of the types are supported");const e=t[0];return uv.isA(e)?vv(t):gv.isA(e)?$v(t):e};var yv=mv;const Qt=N,wv=tn,{Tree:Ps}=en,Pv=(t,e)=>{if(!wv(t,e))return Qt.clone(t);const n=new Ps(Qt.toPolygons(t)),s=new Ps(Qt.toPolygons(e));n.invert(),n.clipTo(s),s.clipTo(n,!0),n.addPolygons(s.allPolygons()),n.invert();const o=n.allPolygons();return Qt.create(o)};var xv=Pv;const Ev=G,_v=je,Av=xv,Sv=(...t)=>{t=Ev(t);let e=t.shift();return t.forEach(n=>{e=Av(e,n)}),e=_v(e),e};var Ro=Sv;const bv=G,Mv=N,Tv=Ye,Fv=We,Vv=Ke,kv=Ro,Nv=(...t)=>{t=bv(t);const e=t.map(o=>Vv({z0:-1,z1:1},o)),n=kv(e),s=Tv(n);return Fv(s,Mv.toPolygons(n))};var qv=Nv;const Cv=G,Bv=le,Ov=R,zv=N,Dv=qv,Rv=Ro,Lv=(...t)=>{if(t=Cv(t),t.length===0)throw new Error("wrong number of arguments");if(!Bv(t))throw new Error("only subtract of the types are supported");const e=t[0];return Ov.isA(e)?Dv(t):zv.isA(e)?Rv(t):e};var Iv=Lv;const xt=N,Gv=tn,{Tree:xs}=en,Zv=(t,e)=>{if(!Gv(t,e))return Hv(t,e);const n=new xs(xt.toPolygons(t)),s=new xs(xt.toPolygons(e));n.clipTo(s,!1),s.clipTo(n),s.invert(),s.clipTo(n),s.invert();const o=n.allPolygons().concat(s.allPolygons());return xt.create(o)},Hv=(t,e)=>{let n=xt.toPolygons(t);return n=n.concat(xt.toPolygons(e)),xt.create(n)};var Uv=Zv;const Xv=G,Yv=je,Wv=Uv,Kv=(...t)=>{t=Xv(t);let e;for(e=1;e<t.length;e+=2)t.push(Wv(t[e-1],t[e]));let n=t[e-1];return n=Yv(n),n};var Lo=Kv;const Qv=G,Jv=N,jv=Ye,t2=We,e2=Ke,n2=Lo,s2=(...t)=>{t=Qv(t);const e=t.map(o=>e2({z0:-1,z1:1},o)),n=n2(e),s=jv(n);return t2(s,Jv.toPolygons(n))};var o2=s2;const r2=G,c2=le,i2=R,a2=N,l2=o2,f2=Lo,h2=(...t)=>{if(t=r2(t),t.length===0)throw new Error("wrong number of arguments");if(!c2(t))throw new Error("only unions of the same type are supported");const e=t[0];return i2.isA(e)?l2(t):a2.isA(e)?f2(t):e};var p2=h2,be={intersect:yv,subtract:Iv,union:p2};const d2=G,Es=D,_s=R,As=N,Ss=tt,u2=(t,...e)=>{if(!Array.isArray(t))throw new Error("factors must be an array");if(e=d2(e),e.length===0)throw new Error("wrong number of arguments");for(t=t.slice();t.length<3;)t.push(1);if(t[0]<=0||t[1]<=0||t[2]<=0)throw new Error("factors must be positive");const n=Es.fromScaling(Es.create(),t),s=e.map(o=>Ss.isA(o)?Ss.transform(n,o):_s.isA(o)?_s.transform(n,o):As.isA(o)?As.transform(n,o):o);return s.length===1?s[0]:s};var g2={scale:u2},Me={rotate:Qd.rotate,scale:g2.scale,translate:tu.translate};const Vt=D,Te=T,v2=R,Fe=He,$2=Yd,m2=(t,e)=>{const n={offset:[0,0,1],twistAngle:0,twistSteps:12,repair:!0};let{offset:s,twistAngle:o,twistSteps:r,repair:c}=Object.assign({},n,t);if(r<1)throw new Error("twistSteps must be 1 or more");o===0&&(r=1);const i=Te.clone(s),l=v2.toSides(e);if(l.length===0)throw new Error("the given geometry cannot be empty");const a=Fe.fromSides(l);i[2]<0&&Fe.reverse(a,a);const f=Vt.create(),h=(p,u,d)=>{const g=u/r*o,y=Te.scale(Te.create(),i,u/r);return Vt.multiply(f,Vt.fromZRotation(f,g),Vt.fromTranslation(Vt.create(),y)),Fe.transform(f,d)};return t={numberOfSlices:r+1,capStart:!0,capEnd:!0,repair:c,callback:h},$2(t,a)};var Io=m2;const y2=R,w2=tt,P2=Io,x2=(t,e)=>{if(!e.isClosed)throw new Error("extruded path must be closed");const n=w2.toPoints(e),s=y2.fromPoints(n);return P2(t,s)};var E2=x2;const _2=G,A2=R,S2=tt,b2=Io,M2=E2,T2=(t,...e)=>{const n={height:1,twistAngle:0,twistSteps:1,repair:!0},{height:s,twistAngle:o,twistSteps:r,repair:c}=Object.assign({},n,t);if(e=_2(e),e.length===0)throw new Error("wrong number of arguments");t={offset:[0,0,s],twistAngle:o,twistSteps:r,repair:c};const i=e.map(l=>S2.isA(l)?M2(t,l):A2.isA(l)?b2(t,l):l);return i.length===1?i[0]:i};var F2=T2,V2={extrudeLinear:F2};const bs=k,k2=t=>{let e=bs.fromValues(1/0,1/0);t.forEach(o=>{(o[1]<e[1]||o[1]===e[1]&&o[0]<e[0])&&(e=o)});const n=[];t.forEach(o=>{const r=q2(o[1]-e[1],o[0]-e[0]),c=bs.squaredDistance(o,e);n.push({point:o,angle:r,distSq:c})}),n.sort((o,r)=>o.angle!==r.angle?o.angle-r.angle:o.distSq-r.distSq);const s=[];return n.forEach(o=>{let r=s.length;for(;r>1&&N2(s[r-2],s[r-1],o.point)<=Number.EPSILON;)s.pop(),r=s.length;s.push(o.point)}),s},N2=(t,e,n)=>(e[0]-t[0])*(n[1]-t[1])-(e[1]-t[1])*(n[0]-t[0]),q2=(t,e)=>t===0&&e===0?-1/0:-e/t;var Go=k2;const Ms=R,Ts=N,Fs=tt,C2=t=>{const e=new Set,n=[],s=o=>{const r=o.toString();e.has(r)||(n.push(o),e.add(r))};return t.forEach(o=>{Ms.isA(o)?Ms.toPoints(o).forEach(s):Ts.isA(o)?Ts.toPoints(o).forEach(r=>r.forEach(s)):Fs.isA(o)&&Fs.toPoints(o).forEach(s)}),n};var nn=C2;const B2=G,O2=tt,z2=Go,D2=nn,R2=(...t)=>{t=B2(t);const e=D2(t),n=z2(e);return O2.fromPoints({closed:!0},n)};var L2=R2;const I2=G,Vs=R,G2=Go,Z2=nn,H2=(...t)=>{t=I2(t);const e=Z2(t),n=G2(e);return n.length<3?Vs.create():Vs.fromPoints(n)};var U2=H2;const X2=B,Y2=co,W2=t=>Y2(t,{skipTriangulation:!0}).map(s=>{const o=s.map(r=>t[r]);return X2.create(o)});var K2=W2;const Q2=G,ks=N,J2=nn,j2=K2,t$=(...t)=>{t=Q2(t);const e=J2(t);return e.length===0?ks.create():ks.create(j2(e))};var e$=t$;const n$=G,s$=le,o$=R,r$=N,c$=tt,i$=L2,a$=U2,l$=e$,f$=(...t)=>{if(t=n$(t),t.length===0)throw new Error("wrong number of arguments");if(!s$(t))throw new Error("only hulls of the same type are supported");const e=t[0];return c$.isA(e)?i$(t):o$.isA(e)?a$(t):r$.isA(e)?l$(t):e};var h$=f$,p$={hull:h$};const Ns={cuboid:t=>Xt.cuboid({size:t.size}),cube:t=>Xt.cuboid({size:t.size||[t.radius||10,t.radius||10,t.radius||10]}),cylinder:t=>Xt.cylinder({radius:t.radius,height:t.height,segments:t.segments||16}),sphere:t=>Xt.sphere({radius:t.radius,segments:t.segments||12})},Ve={union:(...t)=>be.union(...t),subtract:(t,...e)=>be.subtract(t,...e),intersect:(...t)=>be.intersect(...t)},qs={translate:(t,e)=>Me.translate(t,e),rotate:(t,e)=>Me.rotate(t,e),scale:(t,e)=>Me.scale(t,e)},Cs={extrudeLinear:(t,e)=>V2.extrudeLinear({height:t.height},e)},Bs={hull:(...t)=>p$.hull(...t)};function d$(t){const e=N.toPolygons(t);if(e.length===0)throw new Error("Geometry has no polygons");const n=new Uint8Array(80);n.fill(0);const s="JSCAD Model";for(let f=0;f<Math.min(s.length,80);f++)n[f]=s.charCodeAt(f);let o=0;for(const f of e){const h=f.vertices;h.length>=3&&(o+=h.length-2)}const r=84+o*50,c=new ArrayBuffer(r),i=new DataView(c);new Uint8Array(c).set(n,0),i.setUint32(80,o,!0);let a=84;for(const f of e){const h=f.vertices;if(h.length<3)continue;const p=h[0],u=h[1],d=h[2],g=[u[0]-p[0],u[1]-p[1],u[2]-p[2]],y=[d[0]-p[0],d[1]-p[1],d[2]-p[2]],M=[g[1]*y[2]-g[2]*y[1],g[2]*y[0]-g[0]*y[2],g[0]*y[1]-g[1]*y[0]],_=Math.sqrt(M[0]**2+M[1]**2+M[2]**2);_>0&&(M[0]/=_,M[1]/=_,M[2]/=_);for(let P=1;P<h.length-1;P++){i.setFloat32(a,M[0],!0),a+=4,i.setFloat32(a,M[1],!0),a+=4,i.setFloat32(a,M[2],!0),a+=4;const w=h[0],$=h[P],v=h[P+1];i.setFloat32(a,w[0],!0),a+=4,i.setFloat32(a,w[1],!0),a+=4,i.setFloat32(a,w[2],!0),a+=4,i.setFloat32(a,$[0],!0),a+=4,i.setFloat32(a,$[1],!0),a+=4,i.setFloat32(a,$[2],!0),a+=4,i.setFloat32(a,v[0],!0),a+=4,i.setFloat32(a,v[1],!0),a+=4,i.setFloat32(a,v[2],!0),a+=4,i.setUint16(a,0,!0),a+=2}}return c}function u$(t){const e=[/eval\s*\(/gi,/Function\s*\(/gi,/import\s+/gi,/fetch\s*\(/gi,/XMLHttpRequest/gi,/localStorage/gi,/sessionStorage/gi,/document\./gi,/window\./gi,/self\./gi,/postMessage\s*\(/gi];for(const n of e)if(n.test(t))throw new Error("Security violation: Dangerous pattern detected in code");if(t.length>5e4)throw new Error("Code too long (max 50000 characters)")}function g$(t){try{u$(t);let s=new Function("primitives","booleans","transforms","extrusions","hulls","require",`${t}

if (typeof main !== "function") {
  throw new Error("Code must define a main() function");
}
return main();`)(Ns,Ve,qs,Cs,Bs,r=>{switch(r){case"@jscad/modeling":return{primitives:Ns,booleans:Ve,transforms:qs,extrusions:Cs,hulls:Bs};default:return{}}});if(!s)throw new Error("main() returned null or undefined");if(Array.isArray(s)){if(s.length===0)throw new Error("main() returned empty array");if(s=s.filter(r=>r&&typeof r=="object"),s.length>1)try{s=Ve.union(...s)}catch{s=s[0]}else s=s[0]}const o=d$(s);return console.log("[WORKER] STL generated:",o.byteLength,"bytes"),o}catch(e){throw console.error("[WORKER] Execution error:",e),e instanceof Error?new Error(`Execution error: ${e.message}`):new Error("Unknown execution error")}}self.onmessage=t=>{const{code:e}=t.data;if(!e||!e.trim()){const n={type:"error",error:"No code provided"};self.postMessage(n);return}console.log("[WORKER] Processing code...");try{const n=g$(e),s={type:"success",data:n};self.postMessage(s,{transfer:[n]})}catch(n){const s=n instanceof Error?n.message:"Unknown error";console.error("[WORKER] Error:",s);const o={type:"error",error:s};self.postMessage(o)}};
